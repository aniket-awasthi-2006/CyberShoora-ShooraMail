{
    "sourceFile": "backend/services/imapService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 11,
            "patches": [
                {
                    "date": 1767969567044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767969810749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -138,9 +138,9 @@\n         date: mail.date || message.internalDate,\r\n         unread: !message.flags.has('\\\\Seen'),\r\n         flagged: message.flags.has('\\\\Flagged'),\r\n         categoryColor: '#2D62ED',\r\n-        category: 'personal',\r\n+        category: category,\r\n         attachments: processedAttachments,\r\n         avatar: '',\r\n         folder: folder,\r\n         important: message.flags.has('Important'),\r\n"
                },
                {
                    "date": 1767970225586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,8 +89,16 @@\n             subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n         );\r\n         if (hasPromotionalKeywords) {\r\n             return 'promotions';\r\n+        }\r\n+\r\n+        // Everything else is considered work\r\n+        return 'work';\r\n+    };\r\n+\r\n+    const category = categorizeEmail(senderEmail, mail.subject);\r\n+\r\n     const processedAttachments = [];\r\n     if (mail.attachments && mail.attachments.length > 0) {\r\n         for (let i = 0; i < mail.attachments.length; i++) {\r\n             const attachment = mail.attachments[i];\r\n@@ -129,9 +137,9 @@\n         date: mail.date || message.internalDate,\r\n         unread: !message.flags.has('\\\\Seen'),\r\n         flagged: message.flags.has('\\\\Flagged'),\r\n         categoryColor: '#2D62ED',\r\n-        category: category,\r\n+        category: 'personal',\r\n         attachments: processedAttachments,\r\n         avatar: '',\r\n         folder: folder,\r\n         important: message.flags.has('Important'),\r\n"
                },
                {
                    "date": 1767970319793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,8 @@\n         return 'work';\r\n     };\r\n \r\n     const category = categorizeEmail(senderEmail, mail.subject);\r\n-\r\n     const processedAttachments = [];\r\n     if (mail.attachments && mail.attachments.length > 0) {\r\n         for (let i = 0; i < mail.attachments.length; i++) {\r\n             const attachment = mail.attachments[i];\r\n"
                },
                {
                    "date": 1767970348932,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,472 @@\n+import { ImapFlow } from 'imapflow';\r\n+import { simpleParser } from 'mailparser';\r\n+import dotenv from 'dotenv';\r\n+import MailComposer from 'nodemailer/lib/mail-composer/index.js';\r\n+import fs from 'fs';\r\n+import path from 'path';\r\n+\r\n+dotenv.config();\r\n+\r\n+// Helper to create a new client instance\r\n+// Note: ImapFlow requires a new instance/connection for distinct lifecycles \r\n+// or you must manage a persistent connection carefully. \r\n+// Here we follow your pattern of \"Connect -> Do Work -> Disconnect\".\r\n+const getClient = (email, password) => {\r\n+    return new ImapFlow({\r\n+        host: process.env.IMAP_HOST || 'imap.cybershoora.com', // Use environment variable\r\n+        port: parseInt(process.env.IMAP_PORT) || 993,\r\n+        secure: process.env.IMAP_SECURE === 'true',\r\n+        tls: {\r\n+            rejectUnauthorized: false // Matches your previous config\r\n+        },\r\n+        auth: {\r\n+            user: email,\r\n+            pass: password,\r\n+        },\r\n+        logger: true // Enable detailed logging for debugging\r\n+    });\r\n+};\r\n+\r\n+const parseEmail = async (message, source, folder = 'inbox') => {\r\n+    // 'source' is the raw email buffer provided by ImapFlow\r\n+    const mail = await simpleParser(source);\r\n+\r\n+    const senderMatch = mail.from?.text.match(/\"([^\"]*)\"/);\r\n+    const emailMatch = mail.from?.text.match(/<([^>]*)>/);\r\n+    const senderName = senderMatch ? senderMatch[1] : (mail.from?.text.split('<')[0].trim() || 'Unknown');\r\n+    const senderEmail = emailMatch ? emailMatch[1] : (mail.from?.text || '');\r\n+\r\n+    const toemailMatch = mail.to?.text.match(/<([^>]*)>/);\r\n+    const toemailName = toemailMatch ? toemailMatch[1] : (mail.to?.text.split('@')[0].trim() || 'Unknown');\r\n+    const toemailEmail = toemailMatch ? toemailMatch[1] : (mail.to?.text || '');\r\n+\r\n+    // Function to categorize email based on sender email address\r\n+    const categorizeEmail = (senderEmail, subject = '') => {\r\n+        if (!senderEmail) return 'personal';\r\n+\r\n+        const email = senderEmail.toLowerCase();\r\n+        const subjectLower = (subject || '').toLowerCase();\r\n+\r\n+        // Personal email providers\r\n+        const personalDomains = [\r\n+            'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\r\n+            'icloud.com', 'me.com', 'live.com', 'msn.com', 'protonmail.com',\r\n+            'mail.com', 'yandex.com', 'zoho.com'\r\n+        ];\r\n+\r\n+        // Promotional/marketing keywords and domains\r\n+        const promotionalKeywords = [\r\n+            'newsletter', 'promotion', 'offer', 'deal', 'sale', 'discount',\r\n+            'marketing', 'advertisement', 'subscribe', 'unsubscribe'\r\n+        ];\r\n+\r\n+        const promotionalDomains = [\r\n+            'mailchimp.com', 'constantcontact.com', 'sendgrid.com',\r\n+            'amazon.com', 'ebay.com', 'facebook.com', 'twitter.com',\r\n+            'instagram.com', 'linkedin.com', 'pinterest.com'\r\n+        ];\r\n+\r\n+        // Check if it's from a personal email provider\r\n+        const emailDomain = email.split('@')[1];\r\n+        if (personalDomains.includes(emailDomain)) {\r\n+            // Check if it might be promotional despite being from personal domain\r\n+            const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n+                subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n+            );\r\n+            if (hasPromotionalKeywords) {\r\n+                return 'promotions';\r\n+            }\r\n+            return 'personal';\r\n+        }\r\n+\r\n+        // Check if it's promotional\r\n+        if (promotionalDomains.includes(emailDomain)) {\r\n+            return 'promotions';\r\n+        }\r\n+\r\n+        // Check for promotional keywords in subject or sender name\r\n+        const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n+            subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n+        );\r\n+        if (hasPromotionalKeywords) {\r\n+            return 'promotions';\r\n+        }\r\n+\r\n+        // Everything else is considered work\r\n+        return 'work';\r\n+    };\r\n+\r\n+    const processedAttachments = [];\r\n+    if (mail.attachments && mail.attachments.length > 0) {\r\n+        for (let i = 0; i < mail.attachments.length; i++) {\r\n+            const attachment = mail.attachments[i];\r\n+            try {\r\n+                // Create direct download link using IMAP message data\r\n+                const imapFolder = folder === 'inbox' ? 'INBOX' : folder.toUpperCase();\r\n+                const downloadUrl = `/api/download-attachment?uid=${message.uid}&folder=${imapFolder}&index=${i}&filename=${encodeURIComponent(attachment.filename || `attachment-${i}`)}`;\r\n+\r\n+                processedAttachments.push({\r\n+                    filename: attachment.filename || `attachment-${i}`,\r\n+                    originalFilename: attachment.filename,\r\n+                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n+                    contentType: attachment.contentType,\r\n+                    url: downloadUrl,\r\n+                    contentId: attachment.contentId,\r\n+                    contentDisposition: attachment.contentDisposition,\r\n+                    // Store content as base64 for inline preview if needed\r\n+                    content: attachment.content && attachment.content.length < 1024 * 1024 ? attachment.content.toString('base64') : null,\r\n+                    isInline: attachment.contentDisposition === 'inline'\r\n+                });\r\n+            } catch (error) {\r\n+                console.error('Error processing attachment:', error);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    return {\r\n+        id: message.uid, // ImapFlow provides UID directly on the message object\r\n+        sender: senderName,\r\n+        senderEmail: senderEmail,\r\n+        to: toemailName,\r\n+        toEmail: toemailEmail,\r\n+        subject: mail.subject,\r\n+        preview: mail.textAsHtml ? mail.textAsHtml.slice(0, 100) : (mail.text ? mail.text.slice(0, 100) : ''),\r\n+        body: mail.html || mail.textAsHtml || mail.text,\r\n+        date: mail.date || message.internalDate,\r\n+        unread: !message.flags.has('\\\\Seen'),\r\n+        flagged: message.flags.has('\\\\Flagged'),\r\n+        categoryColor: '#2D62ED',\r\n+        category: 'personal',\r\n+        attachments: processedAttachments,\r\n+        avatar: '',\r\n+        folder: folder,\r\n+        important: message.flags.has('Important'),\r\n+    };\r\n+};\r\n+\r\n+// Save sent email to \"Sent\" folder\r\n+const saveSentEmail = async (email, password, mailOptions) => {\r\n+    const client = getClient(email, password);\r\n+\r\n+    // 1. Compile the email object into a raw buffer (RFC822 format)\r\n+    const composer = new MailComposer(mailOptions);\r\n+    const messageBuffer = await composer.compile().build();\r\n+\r\n+    await client.connect();\r\n+\r\n+    // 2. Define target folder (Stackmail usually uses \"Sent\")\r\n+    const sentFolder = 'Sent';\r\n+\r\n+    let lock = await client.getMailboxLock(sentFolder);\r\n+    try {\r\n+        // 3. Append the message with the \\Seen flag so it appears read\r\n+        await client.append(sentFolder, messageBuffer, ['\\\\Seen']);\r\n+    } catch (err) {\r\n+        // Optional: Retry with \"Sent Items\" if \"Sent\" fails\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+//fetch inbox\r\n+const fetchInbox = async (email, password, page = 1, limit = 10) => {\r\n+    const client = getClient(email, password);\r\n+    const parsedMails = [];\r\n+    let status;\r\n+\r\n+    await client.connect();\r\n+\r\n+    // We must lock the mailbox to perform operations\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        // Force refresh mailbox by selecting it explicitly to get latest status\r\n+        await client.mailboxOpen('INBOX', { readOnly: true });\r\n+        await client.noop();\r\n+\r\n+        // 1. Get status to find out how many messages are there\r\n+        status = await client.status('INBOX', { messages: true });\r\n+        const total = status.messages;\r\n+\r\n+        // 2. Calculate pagination using UIDs for reliability\r\n+        const offset = (page - 1) * limit;\r\n+        const start = Math.max(1, total - offset - limit + 1);\r\n+        const end = Math.min(total, total - offset);\r\n+        const range = total > 0 ? `${start}:${end}` : '';\r\n+\r\n+        if (total > 0 && start <= end) {\r\n+            // 3. Fetch specific range using sequence numbers but get UID info\r\n+            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n+                const parsed = await parseEmail(message, message.source);\r\n+                parsedMails.push(parsed);\r\n+            }\r\n+        }\r\n+    } finally {\r\n+        // Always release lock\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+\r\n+    const emailUser = email.split('@')[0];\r\n+    const userName = emailUser.split('.').map(name => name.charAt(0).toUpperCase() + name.slice(1)).join(' ');\r\n+\r\n+    // Reverse to show newest first\r\n+    return {\r\n+        userName,\r\n+        mails: parsedMails.reverse(),\r\n+        pagination: {\r\n+            page,\r\n+            limit,\r\n+            total: status.messages,\r\n+            hasNext: page * limit < status.messages,\r\n+            hasPrev: page > 1\r\n+        }\r\n+    };\r\n+};\r\n+\r\n+const fetchEmailsByFolder = async (email, password, folder, page = 1, limit = 20) => {\r\n+    const client = getClient(email, password);\r\n+    const parsedMails = [];\r\n+    let status;\r\n+\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(folder);\r\n+    try {\r\n+        status = await client.status(folder, { messages: true });\r\n+        const total = status.messages;\r\n+\r\n+        // Calculate pagination\r\n+        const offset = (page - 1) * limit;\r\n+        const start = Math.max(1, total - offset - limit + 1);\r\n+        const end = Math.min(total, total - offset);\r\n+        const range = total > 0 ? `${start}:${end}` : '';\r\n+\r\n+        if (total > 0 && start <= end) {\r\n+            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n+                const parsed = await parseEmail(message, message.source, folder);\r\n+                parsedMails.push(parsed);\r\n+            }\r\n+        }\r\n+    } catch (err) {\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+\r\n+    return {\r\n+        folder,\r\n+        mails: parsedMails.reverse(),\r\n+        pagination: {\r\n+            page,\r\n+            limit,\r\n+            total: status.messages,\r\n+            hasNext: page * limit < status.messages,\r\n+            hasPrev: page > 1\r\n+        }\r\n+    };\r\n+};\r\n+\r\n+const markAsRead = async (email, password, messageId, read) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        // 'uid: true' is crucial because we are passing a UID, not a sequence number\r\n+        if (read) {\r\n+            await client.messageFlagsAdd(messageId, ['\\\\Seen'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['\\\\Seen'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const saveDraft = async (email, password, draftData) => {\r\n+    const client = getClient(email, password);\r\n+\r\n+    // Defensively ensure draftData is an object to prevent errors if it's null or undefined.\r\n+    const data = draftData || {};\r\n+\r\n+    // 1. Map your frontend data to Nodemailer structure\r\n+    const mailOptions = {\r\n+        from: email,\r\n+        to: data.to,\r\n+        subject: data.subject,\r\n+        text: data.body, // or data.text depending on your frontend\r\n+        html: data.html || (data.body ? `<p>${data.body}</p>` : '') // A more robust fallback to avoid \"<p>undefined</p>\"\r\n+    };\r\n+\r\n+    // 2. Compile into raw email buffer\r\n+    const composer = new MailComposer(mailOptions);\r\n+    const messageBuffer = await composer.compile().build();\r\n+\r\n+    await client.connect();\r\n+\r\n+    // 3. Determine Drafts Folder\r\n+    // Common names: 'Drafts', 'Draft', '[Gmail]/Drafts'\r\n+    // You can also look it up via client.list() if needed\r\n+    const draftFolder = 'Drafts';\r\n+\r\n+    let lock = await client.getMailboxLock(draftFolder);\r\n+    try {\r\n+        // 4. Append to Drafts folder\r\n+        // We add \\Seen (so it doesn't look like a new unread mail)\r\n+        // We add \\Draft (standard IMAP flag for drafts)\r\n+        await client.append(draftFolder, messageBuffer, ['\\\\Seen', '\\\\Draft']);\r\n+    } catch (err) {\r\n+        throw err; // Re-throw so your API knows it failed\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+    return { success: true };\r\n+};\r\n+\r\n+// Don't forget to export it!\r\n+const toggleStarred = async (email, password, messageId, starred) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        if (starred) {\r\n+            await client.messageFlagsAdd(messageId, ['\\\\Flagged'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['\\\\Flagged'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const toggleImportant = async (email, password, messageId, important) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        if (important) {\r\n+            await client.messageFlagsAdd(messageId, ['Important'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['Important'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+const deleteEmail = async (email, password, messageId, folder = 'INBOX') => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(folder);\r\n+    try {\r\n+        // Mark as deleted\r\n+        await client.messageFlagsAdd(messageId, ['\\\\Deleted'], { uid: true });\r\n+        // Expunge/Delete is handled by messageDelete in ImapFlow or implies expunge depending on server\r\n+        // Using messageDelete is the safest explicit way to remove by UID\r\n+        await client.messageDelete(messageId, { uid: true });\r\n+\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const moveEmail = async (email, password, messageId, destinationFolder, sourceFolder = 'INBOX') => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(sourceFolder);\r\n+    try {\r\n+        // messageMove returns a result object, true usually implies success\r\n+        await client.messageMove(messageId, destinationFolder, { uid: true });\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const downloadAttachment = async (email, password, uid, folder, index) => {\r\n+    console.log('downloadAttachment called with:', { email: email ? '***@***' : 'missing', password: password ? '***' : 'missing', uid, folder, index });\r\n+\r\n+    try {\r\n+        // First, let's just test if we can connect and get basic mailbox info\r\n+        const client = getClient(email, password);\r\n+\r\n+        console.log('Connecting to IMAP server...');\r\n+        await client.connect();\r\n+        console.log('IMAP connection successful');\r\n+\r\n+        try {\r\n+            console.log('Getting mailbox lock for folder:', folder);\r\n+            let lock = await client.getMailboxLock(folder);\r\n+            console.log('Mailbox lock acquired');\r\n+\r\n+            try {\r\n+                console.log('Fetching message with UID:', uid);\r\n+                // Fetch the specific message with full source\r\n+                const message = await client.fetchOne(uid, { source: true, uid: true });\r\n+                console.log('Message fetched, has source:', !!message.source);\r\n+\r\n+                if (!message || !message.source) {\r\n+                    throw new Error('Message not found');\r\n+                }\r\n+\r\n+                console.log('Parsing email message...');\r\n+                // Parse the email to get attachments\r\n+                const mail = await simpleParser(message.source);\r\n+                console.log('Email parsed, attachments count:', mail.attachments ? mail.attachments.length : 0);\r\n+\r\n+                if (!mail.attachments || mail.attachments.length === 0) {\r\n+                    throw new Error('No attachments found in email');\r\n+                }\r\n+\r\n+                if (index >= mail.attachments.length) {\r\n+                    throw new Error(`Attachment index ${index} out of range (total: ${mail.attachments.length})`);\r\n+                }\r\n+\r\n+                const attachment = mail.attachments[index];\r\n+                console.log('Found attachment:', {\r\n+                    filename: attachment.filename,\r\n+                    size: attachment.size ? attachment.size.length : 0,\r\n+                    contentType: attachment.contentType\r\n+                });\r\n+\r\n+                return {\r\n+                    filename: attachment.filename || `attachment-${index}`,\r\n+                    contentType: attachment.contentType || 'application/octet-stream',\r\n+                    content: attachment.content,\r\n+                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n+                    contentDisposition: attachment.contentDisposition || 'attachment'\r\n+                };\r\n+            } finally {\r\n+                lock.release();\r\n+                console.log('Mailbox lock released');\r\n+            }\r\n+        } finally {\r\n+            await client.logout();\r\n+            console.log('IMAP connection closed');\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('Error in downloadAttachment:', error);\r\n+        // Return a more detailed error for debugging\r\n+        throw new Error(`DownloadAttachment failed: ${error.message}`);\r\n+    }\r\n+};\r\n+\r\n+export { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveSentEmail, saveDraft, downloadAttachment };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1767970461867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,64 +39,9 @@\n     const toemailMatch = mail.to?.text.match(/<([^>]*)>/);\r\n     const toemailName = toemailMatch ? toemailMatch[1] : (mail.to?.text.split('@')[0].trim() || 'Unknown');\r\n     const toemailEmail = toemailMatch ? toemailMatch[1] : (mail.to?.text || '');\r\n \r\n-    // Function to categorize email based on sender email address\r\n-    const categorizeEmail = (senderEmail, subject = '') => {\r\n-        if (!senderEmail) return 'personal';\r\n-\r\n-        const email = senderEmail.toLowerCase();\r\n-        const subjectLower = (subject || '').toLowerCase();\r\n-\r\n-        // Personal email providers\r\n-        const personalDomains = [\r\n-            'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\r\n-            'icloud.com', 'me.com', 'live.com', 'msn.com', 'protonmail.com',\r\n-            'mail.com', 'yandex.com', 'zoho.com'\r\n-        ];\r\n-\r\n-        // Promotional/marketing keywords and domains\r\n-        const promotionalKeywords = [\r\n-            'newsletter', 'promotion', 'offer', 'deal', 'sale', 'discount',\r\n-            'marketing', 'advertisement', 'subscribe', 'unsubscribe'\r\n-        ];\r\n-\r\n-        const promotionalDomains = [\r\n-            'mailchimp.com', 'constantcontact.com', 'sendgrid.com',\r\n-            'amazon.com', 'ebay.com', 'facebook.com', 'twitter.com',\r\n-            'instagram.com', 'linkedin.com', 'pinterest.com'\r\n-        ];\r\n-\r\n-        // Check if it's from a personal email provider\r\n-        const emailDomain = email.split('@')[1];\r\n-        if (personalDomains.includes(emailDomain)) {\r\n-            // Check if it might be promotional despite being from personal domain\r\n-            const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n-                subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n-            );\r\n-            if (hasPromotionalKeywords) {\r\n-                return 'promotions';\r\n-            }\r\n-            return 'personal';\r\n-        }\r\n-\r\n-        // Check if it's promotional\r\n-        if (promotionalDomains.includes(emailDomain)) {\r\n-            return 'promotions';\r\n-        }\r\n-\r\n-        // Check for promotional keywords in subject or sender name\r\n-        const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n-            subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n-        );\r\n-        if (hasPromotionalKeywords) {\r\n-            return 'promotions';\r\n-        }\r\n-\r\n-        // Everything else is considered work\r\n-        return 'work';\r\n-    };\r\n-\r\n+    // Process attachments without saving to disk - create direct download links\r\n     const processedAttachments = [];\r\n     if (mail.attachments && mail.attachments.length > 0) {\r\n         for (let i = 0; i < mail.attachments.length; i++) {\r\n             const attachment = mail.attachments[i];\r\n@@ -468,478 +413,5 @@\n         throw new Error(`DownloadAttachment failed: ${error.message}`);\r\n     }\r\n };\r\n \r\n-export { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveSentEmail, saveDraft, downloadAttachment };\n-import { ImapFlow } from 'imapflow';\r\n-import { simpleParser } from 'mailparser';\r\n-import dotenv from 'dotenv';\r\n-import MailComposer from 'nodemailer/lib/mail-composer/index.js';\r\n-import fs from 'fs';\r\n-import path from 'path';\r\n-\r\n-dotenv.config();\r\n-\r\n-// Helper to create a new client instance\r\n-// Note: ImapFlow requires a new instance/connection for distinct lifecycles \r\n-// or you must manage a persistent connection carefully. \r\n-// Here we follow your pattern of \"Connect -> Do Work -> Disconnect\".\r\n-const getClient = (email, password) => {\r\n-    return new ImapFlow({\r\n-        host: process.env.IMAP_HOST || 'imap.cybershoora.com', // Use environment variable\r\n-        port: parseInt(process.env.IMAP_PORT) || 993,\r\n-        secure: process.env.IMAP_SECURE === 'true',\r\n-        tls: {\r\n-            rejectUnauthorized: false // Matches your previous config\r\n-        },\r\n-        auth: {\r\n-            user: email,\r\n-            pass: password,\r\n-        },\r\n-        logger: true // Enable detailed logging for debugging\r\n-    });\r\n-};\r\n-\r\n-const parseEmail = async (message, source, folder = 'inbox') => {\r\n-    // 'source' is the raw email buffer provided by ImapFlow\r\n-    const mail = await simpleParser(source);\r\n-\r\n-    const senderMatch = mail.from?.text.match(/\"([^\"]*)\"/);\r\n-    const emailMatch = mail.from?.text.match(/<([^>]*)>/);\r\n-    const senderName = senderMatch ? senderMatch[1] : (mail.from?.text.split('<')[0].trim() || 'Unknown');\r\n-    const senderEmail = emailMatch ? emailMatch[1] : (mail.from?.text || '');\r\n-\r\n-    const toemailMatch = mail.to?.text.match(/<([^>]*)>/);\r\n-    const toemailName = toemailMatch ? toemailMatch[1] : (mail.to?.text.split('@')[0].trim() || 'Unknown');\r\n-    const toemailEmail = toemailMatch ? toemailMatch[1] : (mail.to?.text || '');\r\n-\r\n-    // Function to categorize email based on sender email address\r\n-    const categorizeEmail = (senderEmail, subject = '') => {\r\n-        if (!senderEmail) return 'personal';\r\n-\r\n-        const email = senderEmail.toLowerCase();\r\n-        const subjectLower = (subject || '').toLowerCase();\r\n-\r\n-        // Personal email providers\r\n-        const personalDomains = [\r\n-            'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\r\n-            'icloud.com', 'me.com', 'live.com', 'msn.com', 'protonmail.com',\r\n-            'mail.com', 'yandex.com', 'zoho.com'\r\n-        ];\r\n-\r\n-        // Promotional/marketing keywords and domains\r\n-        const promotionalKeywords = [\r\n-            'newsletter', 'promotion', 'offer', 'deal', 'sale', 'discount',\r\n-            'marketing', 'advertisement', 'subscribe', 'unsubscribe'\r\n-        ];\r\n-\r\n-        const promotionalDomains = [\r\n-            'mailchimp.com', 'constantcontact.com', 'sendgrid.com',\r\n-            'amazon.com', 'ebay.com', 'facebook.com', 'twitter.com',\r\n-            'instagram.com', 'linkedin.com', 'pinterest.com'\r\n-        ];\r\n-\r\n-        // Check if it's from a personal email provider\r\n-        const emailDomain = email.split('@')[1];\r\n-        if (personalDomains.includes(emailDomain)) {\r\n-            // Check if it might be promotional despite being from personal domain\r\n-            const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n-                subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n-            );\r\n-            if (hasPromotionalKeywords) {\r\n-                return 'promotions';\r\n-            }\r\n-            return 'personal';\r\n-        }\r\n-\r\n-        // Check if it's promotional\r\n-        if (promotionalDomains.includes(emailDomain)) {\r\n-            return 'promotions';\r\n-        }\r\n-\r\n-        // Check for promotional keywords in subject or sender name\r\n-        const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n-            subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n-        );\r\n-        if (hasPromotionalKeywords) {\r\n-            return 'promotions';\r\n-        }\r\n-\r\n-        // Everything else is considered work\r\n-        return 'work';\r\n-    };\r\n-\r\n-    const category = categorizeEmail(senderEmail, mail.subject);\r\n-    const processedAttachments = [];\r\n-    if (mail.attachments && mail.attachments.length > 0) {\r\n-        for (let i = 0; i < mail.attachments.length; i++) {\r\n-            const attachment = mail.attachments[i];\r\n-            try {\r\n-                // Create direct download link using IMAP message data\r\n-                const imapFolder = folder === 'inbox' ? 'INBOX' : folder.toUpperCase();\r\n-                const downloadUrl = `/api/download-attachment?uid=${message.uid}&folder=${imapFolder}&index=${i}&filename=${encodeURIComponent(attachment.filename || `attachment-${i}`)}`;\r\n-\r\n-                processedAttachments.push({\r\n-                    filename: attachment.filename || `attachment-${i}`,\r\n-                    originalFilename: attachment.filename,\r\n-                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n-                    contentType: attachment.contentType,\r\n-                    url: downloadUrl,\r\n-                    contentId: attachment.contentId,\r\n-                    contentDisposition: attachment.contentDisposition,\r\n-                    // Store content as base64 for inline preview if needed\r\n-                    content: attachment.content && attachment.content.length < 1024 * 1024 ? attachment.content.toString('base64') : null,\r\n-                    isInline: attachment.contentDisposition === 'inline'\r\n-                });\r\n-            } catch (error) {\r\n-                console.error('Error processing attachment:', error);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    return {\r\n-        id: message.uid, // ImapFlow provides UID directly on the message object\r\n-        sender: senderName,\r\n-        senderEmail: senderEmail,\r\n-        to: toemailName,\r\n-        toEmail: toemailEmail,\r\n-        subject: mail.subject,\r\n-        preview: mail.textAsHtml ? mail.textAsHtml.slice(0, 100) : (mail.text ? mail.text.slice(0, 100) : ''),\r\n-        body: mail.html || mail.textAsHtml || mail.text,\r\n-        date: mail.date || message.internalDate,\r\n-        unread: !message.flags.has('\\\\Seen'),\r\n-        flagged: message.flags.has('\\\\Flagged'),\r\n-        categoryColor: '#2D62ED',\r\n-        category: 'personal',\r\n-        attachments: processedAttachments,\r\n-        avatar: '',\r\n-        folder: folder,\r\n-        important: message.flags.has('Important'),\r\n-    };\r\n-};\r\n-\r\n-// Save sent email to \"Sent\" folder\r\n-const saveSentEmail = async (email, password, mailOptions) => {\r\n-    const client = getClient(email, password);\r\n-\r\n-    // 1. Compile the email object into a raw buffer (RFC822 format)\r\n-    const composer = new MailComposer(mailOptions);\r\n-    const messageBuffer = await composer.compile().build();\r\n-\r\n-    await client.connect();\r\n-\r\n-    // 2. Define target folder (Stackmail usually uses \"Sent\")\r\n-    const sentFolder = 'Sent';\r\n-\r\n-    let lock = await client.getMailboxLock(sentFolder);\r\n-    try {\r\n-        // 3. Append the message with the \\Seen flag so it appears read\r\n-        await client.append(sentFolder, messageBuffer, ['\\\\Seen']);\r\n-    } catch (err) {\r\n-        // Optional: Retry with \"Sent Items\" if \"Sent\" fails\r\n-    } finally {\r\n-        lock.release();\r\n-    }\r\n-\r\n-    await client.logout();\r\n-};\r\n-\r\n-//fetch inbox\r\n-const fetchInbox = async (email, password, page = 1, limit = 10) => {\r\n-    const client = getClient(email, password);\r\n-    const parsedMails = [];\r\n-    let status;\r\n-\r\n-    await client.connect();\r\n-\r\n-    // We must lock the mailbox to perform operations\r\n-    let lock = await client.getMailboxLock('INBOX');\r\n-    try {\r\n-        // Force refresh mailbox by selecting it explicitly to get latest status\r\n-        await client.mailboxOpen('INBOX', { readOnly: true });\r\n-        await client.noop();\r\n-\r\n-        // 1. Get status to find out how many messages are there\r\n-        status = await client.status('INBOX', { messages: true });\r\n-        const total = status.messages;\r\n-\r\n-        // 2. Calculate pagination using UIDs for reliability\r\n-        const offset = (page - 1) * limit;\r\n-        const start = Math.max(1, total - offset - limit + 1);\r\n-        const end = Math.min(total, total - offset);\r\n-        const range = total > 0 ? `${start}:${end}` : '';\r\n-\r\n-        if (total > 0 && start <= end) {\r\n-            // 3. Fetch specific range using sequence numbers but get UID info\r\n-            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n-                const parsed = await parseEmail(message, message.source);\r\n-                parsedMails.push(parsed);\r\n-            }\r\n-        }\r\n-    } finally {\r\n-        // Always release lock\r\n-        lock.release();\r\n-    }\r\n-\r\n-    await client.logout();\r\n-\r\n-    const emailUser = email.split('@')[0];\r\n-    const userName = emailUser.split('.').map(name => name.charAt(0).toUpperCase() + name.slice(1)).join(' ');\r\n-\r\n-    // Reverse to show newest first\r\n-    return {\r\n-        userName,\r\n-        mails: parsedMails.reverse(),\r\n-        pagination: {\r\n-            page,\r\n-            limit,\r\n-            total: status.messages,\r\n-            hasNext: page * limit < status.messages,\r\n-            hasPrev: page > 1\r\n-        }\r\n-    };\r\n-};\r\n-\r\n-const fetchEmailsByFolder = async (email, password, folder, page = 1, limit = 20) => {\r\n-    const client = getClient(email, password);\r\n-    const parsedMails = [];\r\n-    let status;\r\n-\r\n-    await client.connect();\r\n-\r\n-    let lock = await client.getMailboxLock(folder);\r\n-    try {\r\n-        status = await client.status(folder, { messages: true });\r\n-        const total = status.messages;\r\n-\r\n-        // Calculate pagination\r\n-        const offset = (page - 1) * limit;\r\n-        const start = Math.max(1, total - offset - limit + 1);\r\n-        const end = Math.min(total, total - offset);\r\n-        const range = total > 0 ? `${start}:${end}` : '';\r\n-\r\n-        if (total > 0 && start <= end) {\r\n-            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n-                const parsed = await parseEmail(message, message.source, folder);\r\n-                parsedMails.push(parsed);\r\n-            }\r\n-        }\r\n-    } catch (err) {\r\n-    } finally {\r\n-        lock.release();\r\n-    }\r\n-\r\n-    await client.logout();\r\n-\r\n-    return {\r\n-        folder,\r\n-        mails: parsedMails.reverse(),\r\n-        pagination: {\r\n-            page,\r\n-            limit,\r\n-            total: status.messages,\r\n-            hasNext: page * limit < status.messages,\r\n-            hasPrev: page > 1\r\n-        }\r\n-    };\r\n-};\r\n-\r\n-const markAsRead = async (email, password, messageId, read) => {\r\n-    const client = getClient(email, password);\r\n-    await client.connect();\r\n-\r\n-    let lock = await client.getMailboxLock('INBOX');\r\n-    try {\r\n-        // 'uid: true' is crucial because we are passing a UID, not a sequence number\r\n-        if (read) {\r\n-            await client.messageFlagsAdd(messageId, ['\\\\Seen'], { uid: true });\r\n-        } else {\r\n-            await client.messageFlagsRemove(messageId, ['\\\\Seen'], { uid: true });\r\n-        }\r\n-    } finally {\r\n-        lock.release();\r\n-    }\r\n-\r\n-    await client.logout();\r\n-};\r\n-\r\n-const saveDraft = async (email, password, draftData) => {\r\n-    const client = getClient(email, password);\r\n-\r\n-    // Defensively ensure draftData is an object to prevent errors if it's null or undefined.\r\n-    const data = draftData || {};\r\n-\r\n-    // 1. Map your frontend data to Nodemailer structure\r\n-    const mailOptions = {\r\n-        from: email,\r\n-        to: data.to,\r\n-        subject: data.subject,\r\n-        text: data.body, // or data.text depending on your frontend\r\n-        html: data.html || (data.body ? `<p>${data.body}</p>` : '') // A more robust fallback to avoid \"<p>undefined</p>\"\r\n-    };\r\n-\r\n-    // 2. Compile into raw email buffer\r\n-    const composer = new MailComposer(mailOptions);\r\n-    const messageBuffer = await composer.compile().build();\r\n-\r\n-    await client.connect();\r\n-\r\n-    // 3. Determine Drafts Folder\r\n-    // Common names: 'Drafts', 'Draft', '[Gmail]/Drafts'\r\n-    // You can also look it up via client.list() if needed\r\n-    const draftFolder = 'Drafts';\r\n-\r\n-    let lock = await client.getMailboxLock(draftFolder);\r\n-    try {\r\n-        // 4. Append to Drafts folder\r\n-        // We add \\Seen (so it doesn't look like a new unread mail)\r\n-        // We add \\Draft (standard IMAP flag for drafts)\r\n-        await client.append(draftFolder, messageBuffer, ['\\\\Seen', '\\\\Draft']);\r\n-    } catch (err) {\r\n-        throw err; // Re-throw so your API knows it failed\r\n-    } finally {\r\n-        lock.release();\r\n-    }\r\n-\r\n-    await client.logout();\r\n-    return { success: true };\r\n-};\r\n-\r\n-// Don't forget to export it!\r\n-const toggleStarred = async (email, password, messageId, starred) => {\r\n-    const client = getClient(email, password);\r\n-    await client.connect();\r\n-\r\n-    let lock = await client.getMailboxLock('INBOX');\r\n-    try {\r\n-        if (starred) {\r\n-            await client.messageFlagsAdd(messageId, ['\\\\Flagged'], { uid: true });\r\n-        } else {\r\n-            await client.messageFlagsRemove(messageId, ['\\\\Flagged'], { uid: true });\r\n-        }\r\n-    } finally {\r\n-        lock.release();\r\n-    }\r\n-\r\n-    await client.logout();\r\n-};\r\n-\r\n-const toggleImportant = async (email, password, messageId, important) => {\r\n-    const client = getClient(email, password);\r\n-    await client.connect();\r\n-\r\n-    let lock = await client.getMailboxLock('INBOX');\r\n-    try {\r\n-        if (important) {\r\n-            await client.messageFlagsAdd(messageId, ['Important'], { uid: true });\r\n-        } else {\r\n-            await client.messageFlagsRemove(messageId, ['Important'], { uid: true });\r\n-        }\r\n-    } finally {\r\n-        lock.release();\r\n-    }\r\n-\r\n-    await client.logout();\r\n-};\r\n-const deleteEmail = async (email, password, messageId, folder = 'INBOX') => {\r\n-    const client = getClient(email, password);\r\n-    await client.connect();\r\n-\r\n-    let lock = await client.getMailboxLock(folder);\r\n-    try {\r\n-        // Mark as deleted\r\n-        await client.messageFlagsAdd(messageId, ['\\\\Deleted'], { uid: true });\r\n-        // Expunge/Delete is handled by messageDelete in ImapFlow or implies expunge depending on server\r\n-        // Using messageDelete is the safest explicit way to remove by UID\r\n-        await client.messageDelete(messageId, { uid: true });\r\n-\r\n-    } finally {\r\n-        lock.release();\r\n-    }\r\n-\r\n-    await client.logout();\r\n-};\r\n-\r\n-const moveEmail = async (email, password, messageId, destinationFolder, sourceFolder = 'INBOX') => {\r\n-    const client = getClient(email, password);\r\n-    await client.connect();\r\n-\r\n-    let lock = await client.getMailboxLock(sourceFolder);\r\n-    try {\r\n-        // messageMove returns a result object, true usually implies success\r\n-        await client.messageMove(messageId, destinationFolder, { uid: true });\r\n-    } finally {\r\n-        lock.release();\r\n-    }\r\n-\r\n-    await client.logout();\r\n-};\r\n-\r\n-const downloadAttachment = async (email, password, uid, folder, index) => {\r\n-    console.log('downloadAttachment called with:', { email: email ? '***@***' : 'missing', password: password ? '***' : 'missing', uid, folder, index });\r\n-\r\n-    try {\r\n-        // First, let's just test if we can connect and get basic mailbox info\r\n-        const client = getClient(email, password);\r\n-\r\n-        console.log('Connecting to IMAP server...');\r\n-        await client.connect();\r\n-        console.log('IMAP connection successful');\r\n-\r\n-        try {\r\n-            console.log('Getting mailbox lock for folder:', folder);\r\n-            let lock = await client.getMailboxLock(folder);\r\n-            console.log('Mailbox lock acquired');\r\n-\r\n-            try {\r\n-                console.log('Fetching message with UID:', uid);\r\n-                // Fetch the specific message with full source\r\n-                const message = await client.fetchOne(uid, { source: true, uid: true });\r\n-                console.log('Message fetched, has source:', !!message.source);\r\n-\r\n-                if (!message || !message.source) {\r\n-                    throw new Error('Message not found');\r\n-                }\r\n-\r\n-                console.log('Parsing email message...');\r\n-                // Parse the email to get attachments\r\n-                const mail = await simpleParser(message.source);\r\n-                console.log('Email parsed, attachments count:', mail.attachments ? mail.attachments.length : 0);\r\n-\r\n-                if (!mail.attachments || mail.attachments.length === 0) {\r\n-                    throw new Error('No attachments found in email');\r\n-                }\r\n-\r\n-                if (index >= mail.attachments.length) {\r\n-                    throw new Error(`Attachment index ${index} out of range (total: ${mail.attachments.length})`);\r\n-                }\r\n-\r\n-                const attachment = mail.attachments[index];\r\n-                console.log('Found attachment:', {\r\n-                    filename: attachment.filename,\r\n-                    size: attachment.size ? attachment.size.length : 0,\r\n-                    contentType: attachment.contentType\r\n-                });\r\n-\r\n-                return {\r\n-                    filename: attachment.filename || `attachment-${index}`,\r\n-                    contentType: attachment.contentType || 'application/octet-stream',\r\n-                    content: attachment.content,\r\n-                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n-                    contentDisposition: attachment.contentDisposition || 'attachment'\r\n-                };\r\n-            } finally {\r\n-                lock.release();\r\n-                console.log('Mailbox lock released');\r\n-            }\r\n-        } finally {\r\n-            await client.logout();\r\n-            console.log('IMAP connection closed');\r\n-        }\r\n-    } catch (error) {\r\n-        console.error('Error in downloadAttachment:', error);\r\n-        // Return a more detailed error for debugging\r\n-        throw new Error(`DownloadAttachment failed: ${error.message}`);\r\n-    }\r\n-};\r\n-\r\n export { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveSentEmail, saveDraft, downloadAttachment };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1767970473619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,475 @@\n+import { ImapFlow } from 'imapflow';\r\n+import { simpleParser } from 'mailparser';\r\n+import dotenv from 'dotenv';\r\n+import MailComposer from 'nodemailer/lib/mail-composer/index.js';\r\n+import fs from 'fs';\r\n+import path from 'path';\r\n+\r\n+dotenv.config();\r\n+\r\n+// Helper to create a new client instance\r\n+// Note: ImapFlow requires a new instance/connection for distinct lifecycles \r\n+// or you must manage a persistent connection carefully. \r\n+// Here we follow your pattern of \"Connect -> Do Work -> Disconnect\".\r\n+const getClient = (email, password) => {\r\n+    return new ImapFlow({\r\n+        host: process.env.IMAP_HOST || 'imap.cybershoora.com', // Use environment variable\r\n+        port: parseInt(process.env.IMAP_PORT) || 993,\r\n+        secure: process.env.IMAP_SECURE === 'true',\r\n+        tls: {\r\n+            rejectUnauthorized: false // Matches your previous config\r\n+        },\r\n+        auth: {\r\n+            user: email,\r\n+            pass: password,\r\n+        },\r\n+        logger: true // Enable detailed logging for debugging\r\n+    });\r\n+};\r\n+\r\n+const parseEmail = async (message, source, folder = 'inbox') => {\r\n+    // 'source' is the raw email buffer provided by ImapFlow\r\n+    const mail = await simpleParser(source);\r\n+\r\n+    const senderMatch = mail.from?.text.match(/\"([^\"]*)\"/);\r\n+    const emailMatch = mail.from?.text.match(/<([^>]*)>/);\r\n+    const senderName = senderMatch ? senderMatch[1] : (mail.from?.text.split('<')[0].trim() || 'Unknown');\r\n+    const senderEmail = emailMatch ? emailMatch[1] : (mail.from?.text || '');\r\n+\r\n+    const toemailMatch = mail.to?.text.match(/<([^>]*)>/);\r\n+    const toemailName = toemailMatch ? toemailMatch[1] : (mail.to?.text.split('@')[0].trim() || 'Unknown');\r\n+    const toemailEmail = toemailMatch ? toemailMatch[1] : (mail.to?.text || '');\r\n+\r\n+    // Function to categorize email based on sender email address\r\n+    const categorizeEmail = (senderEmail, subject = '') => {\r\n+        if (!senderEmail) return 'personal';\r\n+\r\n+        const email = senderEmail.toLowerCase();\r\n+        const subjectLower = (subject || '').toLowerCase();\r\n+\r\n+        // Personal email providers\r\n+        const personalDomains = [\r\n+            'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\r\n+            'icloud.com', 'me.com', 'live.com', 'msn.com', 'protonmail.com',\r\n+            'mail.com', 'yandex.com', 'zoho.com'\r\n+        ];\r\n+\r\n+        // Promotional/marketing keywords and domains\r\n+        const promotionalKeywords = [\r\n+            'newsletter', 'promotion', 'offer', 'deal', 'sale', 'discount',\r\n+            'marketing', 'advertisement', 'subscribe', 'unsubscribe'\r\n+        ];\r\n+\r\n+        const promotionalDomains = [\r\n+            'mailchimp.com', 'constantcontact.com', 'sendgrid.com',\r\n+            'amazon.com', 'ebay.com', 'facebook.com', 'twitter.com',\r\n+            'instagram.com', 'linkedin.com', 'pinterest.com'\r\n+        ];\r\n+\r\n+        // Check if it's from a personal email provider\r\n+        const emailDomain = email.split('@')[1];\r\n+        if (personalDomains.includes(emailDomain)) {\r\n+            // Check if it might be promotional despite being from personal domain\r\n+            const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n+                subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n+            );\r\n+            if (hasPromotionalKeywords) {\r\n+                return 'promotions';\r\n+            }\r\n+            return 'personal';\r\n+        }\r\n+\r\n+        // Check if it's promotional\r\n+        if (promotionalDomains.includes(emailDomain)) {\r\n+            return 'promotions';\r\n+        }\r\n+\r\n+        // Check for promotional keywords in subject or sender name\r\n+        const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n+            subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n+        );\r\n+        if (hasPromotionalKeywords) {\r\n+            return 'promotions';\r\n+        }\r\n+\r\n+        // Everything else is considered work\r\n+        return 'work';\r\n+    };\r\n+\r\n+    const category = categorizeEmail(senderEmail, mail.subject);\r\n+\r\n+    // Process attachments without saving to disk - create direct download links\r\n+    const processedAttachments = [];\r\n+    if (mail.attachments && mail.attachments.length > 0) {\r\n+        for (let i = 0; i < mail.attachments.length; i++) {\r\n+            const attachment = mail.attachments[i];\r\n+            try {\r\n+                // Create direct download link using IMAP message data\r\n+                const imapFolder = folder === 'inbox' ? 'INBOX' : folder.toUpperCase();\r\n+                const downloadUrl = `/api/download-attachment?uid=${message.uid}&folder=${imapFolder}&index=${i}&filename=${encodeURIComponent(attachment.filename || `attachment-${i}`)}`;\r\n+\r\n+                processedAttachments.push({\r\n+                    filename: attachment.filename || `attachment-${i}`,\r\n+                    originalFilename: attachment.filename,\r\n+                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n+                    contentType: attachment.contentType,\r\n+                    url: downloadUrl,\r\n+                    contentId: attachment.contentId,\r\n+                    contentDisposition: attachment.contentDisposition,\r\n+                    // Store content as base64 for inline preview if needed\r\n+                    content: attachment.content && attachment.content.length < 1024 * 1024 ? attachment.content.toString('base64') : null,\r\n+                    isInline: attachment.contentDisposition === 'inline'\r\n+                });\r\n+            } catch (error) {\r\n+                console.error('Error processing attachment:', error);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    return {\r\n+        id: message.uid, // ImapFlow provides UID directly on the message object\r\n+        sender: senderName,\r\n+        senderEmail: senderEmail,\r\n+        to: toemailName,\r\n+        toEmail: toemailEmail,\r\n+        subject: mail.subject,\r\n+        preview: mail.textAsHtml ? mail.textAsHtml.slice(0, 100) : (mail.text ? mail.text.slice(0, 100) : ''),\r\n+        body: mail.html || mail.textAsHtml || mail.text,\r\n+        date: mail.date || message.internalDate,\r\n+        unread: !message.flags.has('\\\\Seen'),\r\n+        flagged: message.flags.has('\\\\Flagged'),\r\n+        categoryColor: '#2D62ED',\r\n+        category: category,\r\n+        attachments: processedAttachments,\r\n+        avatar: '',\r\n+        folder: folder,\r\n+        important: message.flags.has('Important'),\r\n+    };\r\n+};\r\n+\r\n+// Save sent email to \"Sent\" folder\r\n+const saveSentEmail = async (email, password, mailOptions) => {\r\n+    const client = getClient(email, password);\r\n+\r\n+    // 1. Compile the email object into a raw buffer (RFC822 format)\r\n+    const composer = new MailComposer(mailOptions);\r\n+    const messageBuffer = await composer.compile().build();\r\n+\r\n+    await client.connect();\r\n+\r\n+    // 2. Define target folder (Stackmail usually uses \"Sent\")\r\n+    const sentFolder = 'Sent';\r\n+\r\n+    let lock = await client.getMailboxLock(sentFolder);\r\n+    try {\r\n+        // 3. Append the message with the \\Seen flag so it appears read\r\n+        await client.append(sentFolder, messageBuffer, ['\\\\Seen']);\r\n+    } catch (err) {\r\n+        // Optional: Retry with \"Sent Items\" if \"Sent\" fails\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+//fetch inbox\r\n+const fetchInbox = async (email, password, page = 1, limit = 10) => {\r\n+    const client = getClient(email, password);\r\n+    const parsedMails = [];\r\n+    let status;\r\n+\r\n+    await client.connect();\r\n+\r\n+    // We must lock the mailbox to perform operations\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        // Force refresh mailbox by selecting it explicitly to get latest status\r\n+        await client.mailboxOpen('INBOX', { readOnly: true });\r\n+        await client.noop();\r\n+\r\n+        // 1. Get status to find out how many messages are there\r\n+        status = await client.status('INBOX', { messages: true });\r\n+        const total = status.messages;\r\n+\r\n+        // 2. Calculate pagination using UIDs for reliability\r\n+        const offset = (page - 1) * limit;\r\n+        const start = Math.max(1, total - offset - limit + 1);\r\n+        const end = Math.min(total, total - offset);\r\n+        const range = total > 0 ? `${start}:${end}` : '';\r\n+\r\n+        if (total > 0 && start <= end) {\r\n+            // 3. Fetch specific range using sequence numbers but get UID info\r\n+            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n+                const parsed = await parseEmail(message, message.source);\r\n+                parsedMails.push(parsed);\r\n+            }\r\n+        }\r\n+    } finally {\r\n+        // Always release lock\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+\r\n+    const emailUser = email.split('@')[0];\r\n+    const userName = emailUser.split('.').map(name => name.charAt(0).toUpperCase() + name.slice(1)).join(' ');\r\n+\r\n+    // Reverse to show newest first\r\n+    return {\r\n+        userName,\r\n+        mails: parsedMails.reverse(),\r\n+        pagination: {\r\n+            page,\r\n+            limit,\r\n+            total: status.messages,\r\n+            hasNext: page * limit < status.messages,\r\n+            hasPrev: page > 1\r\n+        }\r\n+    };\r\n+};\r\n+\r\n+const fetchEmailsByFolder = async (email, password, folder, page = 1, limit = 20) => {\r\n+    const client = getClient(email, password);\r\n+    const parsedMails = [];\r\n+    let status;\r\n+\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(folder);\r\n+    try {\r\n+        status = await client.status(folder, { messages: true });\r\n+        const total = status.messages;\r\n+\r\n+        // Calculate pagination\r\n+        const offset = (page - 1) * limit;\r\n+        const start = Math.max(1, total - offset - limit + 1);\r\n+        const end = Math.min(total, total - offset);\r\n+        const range = total > 0 ? `${start}:${end}` : '';\r\n+\r\n+        if (total > 0 && start <= end) {\r\n+            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n+                const parsed = await parseEmail(message, message.source, folder);\r\n+                parsedMails.push(parsed);\r\n+            }\r\n+        }\r\n+    } catch (err) {\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+\r\n+    return {\r\n+        folder,\r\n+        mails: parsedMails.reverse(),\r\n+        pagination: {\r\n+            page,\r\n+            limit,\r\n+            total: status.messages,\r\n+            hasNext: page * limit < status.messages,\r\n+            hasPrev: page > 1\r\n+        }\r\n+    };\r\n+};\r\n+\r\n+const markAsRead = async (email, password, messageId, read) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        // 'uid: true' is crucial because we are passing a UID, not a sequence number\r\n+        if (read) {\r\n+            await client.messageFlagsAdd(messageId, ['\\\\Seen'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['\\\\Seen'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const saveDraft = async (email, password, draftData) => {\r\n+    const client = getClient(email, password);\r\n+\r\n+    // Defensively ensure draftData is an object to prevent errors if it's null or undefined.\r\n+    const data = draftData || {};\r\n+\r\n+    // 1. Map your frontend data to Nodemailer structure\r\n+    const mailOptions = {\r\n+        from: email,\r\n+        to: data.to,\r\n+        subject: data.subject,\r\n+        text: data.body, // or data.text depending on your frontend\r\n+        html: data.html || (data.body ? `<p>${data.body}</p>` : '') // A more robust fallback to avoid \"<p>undefined</p>\"\r\n+    };\r\n+\r\n+    // 2. Compile into raw email buffer\r\n+    const composer = new MailComposer(mailOptions);\r\n+    const messageBuffer = await composer.compile().build();\r\n+\r\n+    await client.connect();\r\n+\r\n+    // 3. Determine Drafts Folder\r\n+    // Common names: 'Drafts', 'Draft', '[Gmail]/Drafts'\r\n+    // You can also look it up via client.list() if needed\r\n+    const draftFolder = 'Drafts';\r\n+\r\n+    let lock = await client.getMailboxLock(draftFolder);\r\n+    try {\r\n+        // 4. Append to Drafts folder\r\n+        // We add \\Seen (so it doesn't look like a new unread mail)\r\n+        // We add \\Draft (standard IMAP flag for drafts)\r\n+        await client.append(draftFolder, messageBuffer, ['\\\\Seen', '\\\\Draft']);\r\n+    } catch (err) {\r\n+        throw err; // Re-throw so your API knows it failed\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+    return { success: true };\r\n+};\r\n+\r\n+// Don't forget to export it!\r\n+const toggleStarred = async (email, password, messageId, starred) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        if (starred) {\r\n+            await client.messageFlagsAdd(messageId, ['\\\\Flagged'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['\\\\Flagged'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const toggleImportant = async (email, password, messageId, important) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        if (important) {\r\n+            await client.messageFlagsAdd(messageId, ['Important'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['Important'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+const deleteEmail = async (email, password, messageId, folder = 'INBOX') => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(folder);\r\n+    try {\r\n+        // Mark as deleted\r\n+        await client.messageFlagsAdd(messageId, ['\\\\Deleted'], { uid: true });\r\n+        // Expunge/Delete is handled by messageDelete in ImapFlow or implies expunge depending on server\r\n+        // Using messageDelete is the safest explicit way to remove by UID\r\n+        await client.messageDelete(messageId, { uid: true });\r\n+\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const moveEmail = async (email, password, messageId, destinationFolder, sourceFolder = 'INBOX') => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(sourceFolder);\r\n+    try {\r\n+        // messageMove returns a result object, true usually implies success\r\n+        await client.messageMove(messageId, destinationFolder, { uid: true });\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const downloadAttachment = async (email, password, uid, folder, index) => {\r\n+    console.log('downloadAttachment called with:', { email: email ? '***@***' : 'missing', password: password ? '***' : 'missing', uid, folder, index });\r\n+\r\n+    try {\r\n+        // First, let's just test if we can connect and get basic mailbox info\r\n+        const client = getClient(email, password);\r\n+\r\n+        console.log('Connecting to IMAP server...');\r\n+        await client.connect();\r\n+        console.log('IMAP connection successful');\r\n+\r\n+        try {\r\n+            console.log('Getting mailbox lock for folder:', folder);\r\n+            let lock = await client.getMailboxLock(folder);\r\n+            console.log('Mailbox lock acquired');\r\n+\r\n+            try {\r\n+                console.log('Fetching message with UID:', uid);\r\n+                // Fetch the specific message with full source\r\n+                const message = await client.fetchOne(uid, { source: true, uid: true });\r\n+                console.log('Message fetched, has source:', !!message.source);\r\n+\r\n+                if (!message || !message.source) {\r\n+                    throw new Error('Message not found');\r\n+                }\r\n+\r\n+                console.log('Parsing email message...');\r\n+                // Parse the email to get attachments\r\n+                const mail = await simpleParser(message.source);\r\n+                console.log('Email parsed, attachments count:', mail.attachments ? mail.attachments.length : 0);\r\n+\r\n+                if (!mail.attachments || mail.attachments.length === 0) {\r\n+                    throw new Error('No attachments found in email');\r\n+                }\r\n+\r\n+                if (index >= mail.attachments.length) {\r\n+                    throw new Error(`Attachment index ${index} out of range (total: ${mail.attachments.length})`);\r\n+                }\r\n+\r\n+                const attachment = mail.attachments[index];\r\n+                console.log('Found attachment:', {\r\n+                    filename: attachment.filename,\r\n+                    size: attachment.size ? attachment.size.length : 0,\r\n+                    contentType: attachment.contentType\r\n+                });\r\n+\r\n+                return {\r\n+                    filename: attachment.filename || `attachment-${index}`,\r\n+                    contentType: attachment.contentType || 'application/octet-stream',\r\n+                    content: attachment.content,\r\n+                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n+                    contentDisposition: attachment.contentDisposition || 'attachment'\r\n+                };\r\n+            } finally {\r\n+                lock.release();\r\n+                console.log('Mailbox lock released');\r\n+            }\r\n+        } finally {\r\n+            await client.logout();\r\n+            console.log('IMAP connection closed');\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('Error in downloadAttachment:', error);\r\n+        // Return a more detailed error for debugging\r\n+        throw new Error(`DownloadAttachment failed: ${error.message}`);\r\n+    }\r\n+};\r\n+\r\n+export { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveSentEmail, saveDraft, downloadAttachment };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1767970495367,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,417 @@\n+import { ImapFlow } from 'imapflow';\r\n+import { simpleParser } from 'mailparser';\r\n+import dotenv from 'dotenv';\r\n+import MailComposer from 'nodemailer/lib/mail-composer/index.js';\r\n+import fs from 'fs';\r\n+import path from 'path';\r\n+\r\n+dotenv.config();\r\n+\r\n+// Helper to create a new client instance\r\n+// Note: ImapFlow requires a new instance/connection for distinct lifecycles \r\n+// or you must manage a persistent connection carefully. \r\n+// Here we follow your pattern of \"Connect -> Do Work -> Disconnect\".\r\n+const getClient = (email, password) => {\r\n+    return new ImapFlow({\r\n+        host: process.env.IMAP_HOST || 'imap.cybershoora.com', // Use environment variable\r\n+        port: parseInt(process.env.IMAP_PORT) || 993,\r\n+        secure: process.env.IMAP_SECURE === 'true',\r\n+        tls: {\r\n+            rejectUnauthorized: false // Matches your previous config\r\n+        },\r\n+        auth: {\r\n+            user: email,\r\n+            pass: password,\r\n+        },\r\n+        logger: true // Enable detailed logging for debugging\r\n+    });\r\n+};\r\n+\r\n+const parseEmail = async (message, source, folder = 'inbox') => {\r\n+    // 'source' is the raw email buffer provided by ImapFlow\r\n+    const mail = await simpleParser(source);\r\n+\r\n+    const senderMatch = mail.from?.text.match(/\"([^\"]*)\"/);\r\n+    const emailMatch = mail.from?.text.match(/<([^>]*)>/);\r\n+    const senderName = senderMatch ? senderMatch[1] : (mail.from?.text.split('<')[0].trim() || 'Unknown');\r\n+    const senderEmail = emailMatch ? emailMatch[1] : (mail.from?.text || '');\r\n+\r\n+    const toemailMatch = mail.to?.text.match(/<([^>]*)>/);\r\n+    const toemailName = toemailMatch ? toemailMatch[1] : (mail.to?.text.split('@')[0].trim() || 'Unknown');\r\n+    const toemailEmail = toemailMatch ? toemailMatch[1] : (mail.to?.text || '');\r\n+\r\n+    // Process attachments without saving to disk - create direct download links\r\n+    const processedAttachments = [];\r\n+    if (mail.attachments && mail.attachments.length > 0) {\r\n+        for (let i = 0; i < mail.attachments.length; i++) {\r\n+            const attachment = mail.attachments[i];\r\n+            try {\r\n+                // Create direct download link using IMAP message data\r\n+                const imapFolder = folder === 'inbox' ? 'INBOX' : folder.toUpperCase();\r\n+                const downloadUrl = `/api/download-attachment?uid=${message.uid}&folder=${imapFolder}&index=${i}&filename=${encodeURIComponent(attachment.filename || `attachment-${i}`)}`;\r\n+\r\n+                processedAttachments.push({\r\n+                    filename: attachment.filename || `attachment-${i}`,\r\n+                    originalFilename: attachment.filename,\r\n+                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n+                    contentType: attachment.contentType,\r\n+                    url: downloadUrl,\r\n+                    contentId: attachment.contentId,\r\n+                    contentDisposition: attachment.contentDisposition,\r\n+                    // Store content as base64 for inline preview if needed\r\n+                    content: attachment.content && attachment.content.length < 1024 * 1024 ? attachment.content.toString('base64') : null,\r\n+                    isInline: attachment.contentDisposition === 'inline'\r\n+                });\r\n+            } catch (error) {\r\n+                console.error('Error processing attachment:', error);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    return {\r\n+        id: message.uid, // ImapFlow provides UID directly on the message object\r\n+        sender: senderName,\r\n+        senderEmail: senderEmail,\r\n+        to: toemailName,\r\n+        toEmail: toemailEmail,\r\n+        subject: mail.subject,\r\n+        preview: mail.textAsHtml ? mail.textAsHtml.slice(0, 100) : (mail.text ? mail.text.slice(0, 100) : ''),\r\n+        body: mail.html || mail.textAsHtml || mail.text,\r\n+        date: mail.date || message.internalDate,\r\n+        unread: !message.flags.has('\\\\Seen'),\r\n+        flagged: message.flags.has('\\\\Flagged'),\r\n+        categoryColor: '#2D62ED',\r\n+        category: 'personal',\r\n+        attachments: processedAttachments,\r\n+        avatar: '',\r\n+        folder: folder,\r\n+        important: message.flags.has('Important'),\r\n+    };\r\n+};\r\n+\r\n+// Save sent email to \"Sent\" folder\r\n+const saveSentEmail = async (email, password, mailOptions) => {\r\n+    const client = getClient(email, password);\r\n+\r\n+    // 1. Compile the email object into a raw buffer (RFC822 format)\r\n+    const composer = new MailComposer(mailOptions);\r\n+    const messageBuffer = await composer.compile().build();\r\n+\r\n+    await client.connect();\r\n+\r\n+    // 2. Define target folder (Stackmail usually uses \"Sent\")\r\n+    const sentFolder = 'Sent';\r\n+\r\n+    let lock = await client.getMailboxLock(sentFolder);\r\n+    try {\r\n+        // 3. Append the message with the \\Seen flag so it appears read\r\n+        await client.append(sentFolder, messageBuffer, ['\\\\Seen']);\r\n+    } catch (err) {\r\n+        // Optional: Retry with \"Sent Items\" if \"Sent\" fails\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+//fetch inbox\r\n+const fetchInbox = async (email, password, page = 1, limit = 10) => {\r\n+    const client = getClient(email, password);\r\n+    const parsedMails = [];\r\n+    let status;\r\n+\r\n+    await client.connect();\r\n+\r\n+    // We must lock the mailbox to perform operations\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        // Force refresh mailbox by selecting it explicitly to get latest status\r\n+        await client.mailboxOpen('INBOX', { readOnly: true });\r\n+        await client.noop();\r\n+\r\n+        // 1. Get status to find out how many messages are there\r\n+        status = await client.status('INBOX', { messages: true });\r\n+        const total = status.messages;\r\n+\r\n+        // 2. Calculate pagination using UIDs for reliability\r\n+        const offset = (page - 1) * limit;\r\n+        const start = Math.max(1, total - offset - limit + 1);\r\n+        const end = Math.min(total, total - offset);\r\n+        const range = total > 0 ? `${start}:${end}` : '';\r\n+\r\n+        if (total > 0 && start <= end) {\r\n+            // 3. Fetch specific range using sequence numbers but get UID info\r\n+            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n+                const parsed = await parseEmail(message, message.source);\r\n+                parsedMails.push(parsed);\r\n+            }\r\n+        }\r\n+    } finally {\r\n+        // Always release lock\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+\r\n+    const emailUser = email.split('@')[0];\r\n+    const userName = emailUser.split('.').map(name => name.charAt(0).toUpperCase() + name.slice(1)).join(' ');\r\n+\r\n+    // Reverse to show newest first\r\n+    return {\r\n+        userName,\r\n+        mails: parsedMails.reverse(),\r\n+        pagination: {\r\n+            page,\r\n+            limit,\r\n+            total: status.messages,\r\n+            hasNext: page * limit < status.messages,\r\n+            hasPrev: page > 1\r\n+        }\r\n+    };\r\n+};\r\n+\r\n+const fetchEmailsByFolder = async (email, password, folder, page = 1, limit = 20) => {\r\n+    const client = getClient(email, password);\r\n+    const parsedMails = [];\r\n+    let status;\r\n+\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(folder);\r\n+    try {\r\n+        status = await client.status(folder, { messages: true });\r\n+        const total = status.messages;\r\n+\r\n+        // Calculate pagination\r\n+        const offset = (page - 1) * limit;\r\n+        const start = Math.max(1, total - offset - limit + 1);\r\n+        const end = Math.min(total, total - offset);\r\n+        const range = total > 0 ? `${start}:${end}` : '';\r\n+\r\n+        if (total > 0 && start <= end) {\r\n+            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n+                const parsed = await parseEmail(message, message.source, folder);\r\n+                parsedMails.push(parsed);\r\n+            }\r\n+        }\r\n+    } catch (err) {\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+\r\n+    return {\r\n+        folder,\r\n+        mails: parsedMails.reverse(),\r\n+        pagination: {\r\n+            page,\r\n+            limit,\r\n+            total: status.messages,\r\n+            hasNext: page * limit < status.messages,\r\n+            hasPrev: page > 1\r\n+        }\r\n+    };\r\n+};\r\n+\r\n+const markAsRead = async (email, password, messageId, read) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        // 'uid: true' is crucial because we are passing a UID, not a sequence number\r\n+        if (read) {\r\n+            await client.messageFlagsAdd(messageId, ['\\\\Seen'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['\\\\Seen'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const saveDraft = async (email, password, draftData) => {\r\n+    const client = getClient(email, password);\r\n+\r\n+    // Defensively ensure draftData is an object to prevent errors if it's null or undefined.\r\n+    const data = draftData || {};\r\n+\r\n+    // 1. Map your frontend data to Nodemailer structure\r\n+    const mailOptions = {\r\n+        from: email,\r\n+        to: data.to,\r\n+        subject: data.subject,\r\n+        text: data.body, // or data.text depending on your frontend\r\n+        html: data.html || (data.body ? `<p>${data.body}</p>` : '') // A more robust fallback to avoid \"<p>undefined</p>\"\r\n+    };\r\n+\r\n+    // 2. Compile into raw email buffer\r\n+    const composer = new MailComposer(mailOptions);\r\n+    const messageBuffer = await composer.compile().build();\r\n+\r\n+    await client.connect();\r\n+\r\n+    // 3. Determine Drafts Folder\r\n+    // Common names: 'Drafts', 'Draft', '[Gmail]/Drafts'\r\n+    // You can also look it up via client.list() if needed\r\n+    const draftFolder = 'Drafts';\r\n+\r\n+    let lock = await client.getMailboxLock(draftFolder);\r\n+    try {\r\n+        // 4. Append to Drafts folder\r\n+        // We add \\Seen (so it doesn't look like a new unread mail)\r\n+        // We add \\Draft (standard IMAP flag for drafts)\r\n+        await client.append(draftFolder, messageBuffer, ['\\\\Seen', '\\\\Draft']);\r\n+    } catch (err) {\r\n+        throw err; // Re-throw so your API knows it failed\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+    return { success: true };\r\n+};\r\n+\r\n+// Don't forget to export it!\r\n+const toggleStarred = async (email, password, messageId, starred) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        if (starred) {\r\n+            await client.messageFlagsAdd(messageId, ['\\\\Flagged'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['\\\\Flagged'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const toggleImportant = async (email, password, messageId, important) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        if (important) {\r\n+            await client.messageFlagsAdd(messageId, ['Important'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['Important'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+const deleteEmail = async (email, password, messageId, folder = 'INBOX') => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(folder);\r\n+    try {\r\n+        // Mark as deleted\r\n+        await client.messageFlagsAdd(messageId, ['\\\\Deleted'], { uid: true });\r\n+        // Expunge/Delete is handled by messageDelete in ImapFlow or implies expunge depending on server\r\n+        // Using messageDelete is the safest explicit way to remove by UID\r\n+        await client.messageDelete(messageId, { uid: true });\r\n+\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const moveEmail = async (email, password, messageId, destinationFolder, sourceFolder = 'INBOX') => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(sourceFolder);\r\n+    try {\r\n+        // messageMove returns a result object, true usually implies success\r\n+        await client.messageMove(messageId, destinationFolder, { uid: true });\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const downloadAttachment = async (email, password, uid, folder, index) => {\r\n+    console.log('downloadAttachment called with:', { email: email ? '***@***' : 'missing', password: password ? '***' : 'missing', uid, folder, index });\r\n+\r\n+    try {\r\n+        // First, let's just test if we can connect and get basic mailbox info\r\n+        const client = getClient(email, password);\r\n+\r\n+        console.log('Connecting to IMAP server...');\r\n+        await client.connect();\r\n+        console.log('IMAP connection successful');\r\n+\r\n+        try {\r\n+            console.log('Getting mailbox lock for folder:', folder);\r\n+            let lock = await client.getMailboxLock(folder);\r\n+            console.log('Mailbox lock acquired');\r\n+\r\n+            try {\r\n+                console.log('Fetching message with UID:', uid);\r\n+                // Fetch the specific message with full source\r\n+                const message = await client.fetchOne(uid, { source: true, uid: true });\r\n+                console.log('Message fetched, has source:', !!message.source);\r\n+\r\n+                if (!message || !message.source) {\r\n+                    throw new Error('Message not found');\r\n+                }\r\n+\r\n+                console.log('Parsing email message...');\r\n+                // Parse the email to get attachments\r\n+                const mail = await simpleParser(message.source);\r\n+                console.log('Email parsed, attachments count:', mail.attachments ? mail.attachments.length : 0);\r\n+\r\n+                if (!mail.attachments || mail.attachments.length === 0) {\r\n+                    throw new Error('No attachments found in email');\r\n+                }\r\n+\r\n+                if (index >= mail.attachments.length) {\r\n+                    throw new Error(`Attachment index ${index} out of range (total: ${mail.attachments.length})`);\r\n+                }\r\n+\r\n+                const attachment = mail.attachments[index];\r\n+                console.log('Found attachment:', {\r\n+                    filename: attachment.filename,\r\n+                    size: attachment.size ? attachment.size.length : 0,\r\n+                    contentType: attachment.contentType\r\n+                });\r\n+\r\n+                return {\r\n+                    filename: attachment.filename || `attachment-${index}`,\r\n+                    contentType: attachment.contentType || 'application/octet-stream',\r\n+                    content: attachment.content,\r\n+                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n+                    contentDisposition: attachment.contentDisposition || 'attachment'\r\n+                };\r\n+            } finally {\r\n+                lock.release();\r\n+                console.log('Mailbox lock released');\r\n+            }\r\n+        } finally {\r\n+            await client.logout();\r\n+            console.log('IMAP connection closed');\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('Error in downloadAttachment:', error);\r\n+        // Return a more detailed error for debugging\r\n+        throw new Error(`DownloadAttachment failed: ${error.message}`);\r\n+    }\r\n+};\r\n+\r\n+export { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveSentEmail, saveDraft, downloadAttachment };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1767970500530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,417 @@\n+import { ImapFlow } from 'imapflow';\r\n+import { simpleParser } from 'mailparser';\r\n+import dotenv from 'dotenv';\r\n+import MailComposer from 'nodemailer/lib/mail-composer/index.js';\r\n+import fs from 'fs';\r\n+import path from 'path';\r\n+\r\n+dotenv.config();\r\n+\r\n+// Helper to create a new client instance\r\n+// Note: ImapFlow requires a new instance/connection for distinct lifecycles \r\n+// or you must manage a persistent connection carefully. \r\n+// Here we follow your pattern of \"Connect -> Do Work -> Disconnect\".\r\n+const getClient = (email, password) => {\r\n+    return new ImapFlow({\r\n+        host: process.env.IMAP_HOST || 'imap.cybershoora.com', // Use environment variable\r\n+        port: parseInt(process.env.IMAP_PORT) || 993,\r\n+        secure: process.env.IMAP_SECURE === 'true',\r\n+        tls: {\r\n+            rejectUnauthorized: false // Matches your previous config\r\n+        },\r\n+        auth: {\r\n+            user: email,\r\n+            pass: password,\r\n+        },\r\n+        logger: true // Enable detailed logging for debugging\r\n+    });\r\n+};\r\n+\r\n+const parseEmail = async (message, source, folder = 'inbox') => {\r\n+    // 'source' is the raw email buffer provided by ImapFlow\r\n+    const mail = await simpleParser(source);\r\n+\r\n+    const senderMatch = mail.from?.text.match(/\"([^\"]*)\"/);\r\n+    const emailMatch = mail.from?.text.match(/<([^>]*)>/);\r\n+    const senderName = senderMatch ? senderMatch[1] : (mail.from?.text.split('<')[0].trim() || 'Unknown');\r\n+    const senderEmail = emailMatch ? emailMatch[1] : (mail.from?.text || '');\r\n+\r\n+    const toemailMatch = mail.to?.text.match(/<([^>]*)>/);\r\n+    const toemailName = toemailMatch ? toemailMatch[1] : (mail.to?.text.split('@')[0].trim() || 'Unknown');\r\n+    const toemailEmail = toemailMatch ? toemailMatch[1] : (mail.to?.text || '');\r\n+\r\n+    // Process attachments without saving to disk - create direct download links\r\n+    const processedAttachments = [];\r\n+    if (mail.attachments && mail.attachments.length > 0) {\r\n+        for (let i = 0; i < mail.attachments.length; i++) {\r\n+            const attachment = mail.attachments[i];\r\n+            try {\r\n+                // Create direct download link using IMAP message data\r\n+                const imapFolder = folder === 'inbox' ? 'INBOX' : folder.toUpperCase();\r\n+                const downloadUrl = `/api/download-attachment?uid=${message.uid}&folder=${imapFolder}&index=${i}&filename=${encodeURIComponent(attachment.filename || `attachment-${i}`)}`;\r\n+\r\n+                processedAttachments.push({\r\n+                    filename: attachment.filename || `attachment-${i}`,\r\n+                    originalFilename: attachment.filename,\r\n+                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n+                    contentType: attachment.contentType,\r\n+                    url: downloadUrl,\r\n+                    contentId: attachment.contentId,\r\n+                    contentDisposition: attachment.contentDisposition,\r\n+                    // Store content as base64 for inline preview if needed\r\n+                    content: attachment.content && attachment.content.length < 1024 * 1024 ? attachment.content.toString('base64') : null,\r\n+                    isInline: attachment.contentDisposition === 'inline'\r\n+                });\r\n+            } catch (error) {\r\n+                console.error('Error processing attachment:', error);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    return {\r\n+        id: message.uid, // ImapFlow provides UID directly on the message object\r\n+        sender: senderName,\r\n+        senderEmail: senderEmail,\r\n+        to: toemailName,\r\n+        toEmail: toemailEmail,\r\n+        subject: mail.subject,\r\n+        preview: mail.textAsHtml ? mail.textAsHtml.slice(0, 100) : (mail.text ? mail.text.slice(0, 100) : ''),\r\n+        body: mail.html || mail.textAsHtml || mail.text,\r\n+        date: mail.date || message.internalDate,\r\n+        unread: !message.flags.has('\\\\Seen'),\r\n+        flagged: message.flags.has('\\\\Flagged'),\r\n+        categoryColor: '#2D62ED',\r\n+        category: 'personal',\r\n+        attachments: processedAttachments,\r\n+        avatar: '',\r\n+        folder: folder,\r\n+        important: message.flags.has('Important'),\r\n+    };\r\n+};\r\n+\r\n+// Save sent email to \"Sent\" folder\r\n+const saveSentEmail = async (email, password, mailOptions) => {\r\n+    const client = getClient(email, password);\r\n+\r\n+    // 1. Compile the email object into a raw buffer (RFC822 format)\r\n+    const composer = new MailComposer(mailOptions);\r\n+    const messageBuffer = await composer.compile().build();\r\n+\r\n+    await client.connect();\r\n+\r\n+    // 2. Define target folder (Stackmail usually uses \"Sent\")\r\n+    const sentFolder = 'Sent';\r\n+\r\n+    let lock = await client.getMailboxLock(sentFolder);\r\n+    try {\r\n+        // 3. Append the message with the \\Seen flag so it appears read\r\n+        await client.append(sentFolder, messageBuffer, ['\\\\Seen']);\r\n+    } catch (err) {\r\n+        // Optional: Retry with \"Sent Items\" if \"Sent\" fails\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+//fetch inbox\r\n+const fetchInbox = async (email, password, page = 1, limit = 10) => {\r\n+    const client = getClient(email, password);\r\n+    const parsedMails = [];\r\n+    let status;\r\n+\r\n+    await client.connect();\r\n+\r\n+    // We must lock the mailbox to perform operations\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        // Force refresh mailbox by selecting it explicitly to get latest status\r\n+        await client.mailboxOpen('INBOX', { readOnly: true });\r\n+        await client.noop();\r\n+\r\n+        // 1. Get status to find out how many messages are there\r\n+        status = await client.status('INBOX', { messages: true });\r\n+        const total = status.messages;\r\n+\r\n+        // 2. Calculate pagination using UIDs for reliability\r\n+        const offset = (page - 1) * limit;\r\n+        const start = Math.max(1, total - offset - limit + 1);\r\n+        const end = Math.min(total, total - offset);\r\n+        const range = total > 0 ? `${start}:${end}` : '';\r\n+\r\n+        if (total > 0 && start <= end) {\r\n+            // 3. Fetch specific range using sequence numbers but get UID info\r\n+            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n+                const parsed = await parseEmail(message, message.source);\r\n+                parsedMails.push(parsed);\r\n+            }\r\n+        }\r\n+    } finally {\r\n+        // Always release lock\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+\r\n+    const emailUser = email.split('@')[0];\r\n+    const userName = emailUser.split('.').map(name => name.charAt(0).toUpperCase() + name.slice(1)).join(' ');\r\n+\r\n+    // Reverse to show newest first\r\n+    return {\r\n+        userName,\r\n+        mails: parsedMails.reverse(),\r\n+        pagination: {\r\n+            page,\r\n+            limit,\r\n+            total: status.messages,\r\n+            hasNext: page * limit < status.messages,\r\n+            hasPrev: page > 1\r\n+        }\r\n+    };\r\n+};\r\n+\r\n+const fetchEmailsByFolder = async (email, password, folder, page = 1, limit = 20) => {\r\n+    const client = getClient(email, password);\r\n+    const parsedMails = [];\r\n+    let status;\r\n+\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(folder);\r\n+    try {\r\n+        status = await client.status(folder, { messages: true });\r\n+        const total = status.messages;\r\n+\r\n+        // Calculate pagination\r\n+        const offset = (page - 1) * limit;\r\n+        const start = Math.max(1, total - offset - limit + 1);\r\n+        const end = Math.min(total, total - offset);\r\n+        const range = total > 0 ? `${start}:${end}` : '';\r\n+\r\n+        if (total > 0 && start <= end) {\r\n+            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n+                const parsed = await parseEmail(message, message.source, folder);\r\n+                parsedMails.push(parsed);\r\n+            }\r\n+        }\r\n+    } catch (err) {\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+\r\n+    return {\r\n+        folder,\r\n+        mails: parsedMails.reverse(),\r\n+        pagination: {\r\n+            page,\r\n+            limit,\r\n+            total: status.messages,\r\n+            hasNext: page * limit < status.messages,\r\n+            hasPrev: page > 1\r\n+        }\r\n+    };\r\n+};\r\n+\r\n+const markAsRead = async (email, password, messageId, read) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        // 'uid: true' is crucial because we are passing a UID, not a sequence number\r\n+        if (read) {\r\n+            await client.messageFlagsAdd(messageId, ['\\\\Seen'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['\\\\Seen'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const saveDraft = async (email, password, draftData) => {\r\n+    const client = getClient(email, password);\r\n+\r\n+    // Defensively ensure draftData is an object to prevent errors if it's null or undefined.\r\n+    const data = draftData || {};\r\n+\r\n+    // 1. Map your frontend data to Nodemailer structure\r\n+    const mailOptions = {\r\n+        from: email,\r\n+        to: data.to,\r\n+        subject: data.subject,\r\n+        text: data.body, // or data.text depending on your frontend\r\n+        html: data.html || (data.body ? `<p>${data.body}</p>` : '') // A more robust fallback to avoid \"<p>undefined</p>\"\r\n+    };\r\n+\r\n+    // 2. Compile into raw email buffer\r\n+    const composer = new MailComposer(mailOptions);\r\n+    const messageBuffer = await composer.compile().build();\r\n+\r\n+    await client.connect();\r\n+\r\n+    // 3. Determine Drafts Folder\r\n+    // Common names: 'Drafts', 'Draft', '[Gmail]/Drafts'\r\n+    // You can also look it up via client.list() if needed\r\n+    const draftFolder = 'Drafts';\r\n+\r\n+    let lock = await client.getMailboxLock(draftFolder);\r\n+    try {\r\n+        // 4. Append to Drafts folder\r\n+        // We add \\Seen (so it doesn't look like a new unread mail)\r\n+        // We add \\Draft (standard IMAP flag for drafts)\r\n+        await client.append(draftFolder, messageBuffer, ['\\\\Seen', '\\\\Draft']);\r\n+    } catch (err) {\r\n+        throw err; // Re-throw so your API knows it failed\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+    return { success: true };\r\n+};\r\n+\r\n+// Don't forget to export it!\r\n+const toggleStarred = async (email, password, messageId, starred) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        if (starred) {\r\n+            await client.messageFlagsAdd(messageId, ['\\\\Flagged'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['\\\\Flagged'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const toggleImportant = async (email, password, messageId, important) => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock('INBOX');\r\n+    try {\r\n+        if (important) {\r\n+            await client.messageFlagsAdd(messageId, ['Important'], { uid: true });\r\n+        } else {\r\n+            await client.messageFlagsRemove(messageId, ['Important'], { uid: true });\r\n+        }\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+const deleteEmail = async (email, password, messageId, folder = 'INBOX') => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(folder);\r\n+    try {\r\n+        // Mark as deleted\r\n+        await client.messageFlagsAdd(messageId, ['\\\\Deleted'], { uid: true });\r\n+        // Expunge/Delete is handled by messageDelete in ImapFlow or implies expunge depending on server\r\n+        // Using messageDelete is the safest explicit way to remove by UID\r\n+        await client.messageDelete(messageId, { uid: true });\r\n+\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const moveEmail = async (email, password, messageId, destinationFolder, sourceFolder = 'INBOX') => {\r\n+    const client = getClient(email, password);\r\n+    await client.connect();\r\n+\r\n+    let lock = await client.getMailboxLock(sourceFolder);\r\n+    try {\r\n+        // messageMove returns a result object, true usually implies success\r\n+        await client.messageMove(messageId, destinationFolder, { uid: true });\r\n+    } finally {\r\n+        lock.release();\r\n+    }\r\n+\r\n+    await client.logout();\r\n+};\r\n+\r\n+const downloadAttachment = async (email, password, uid, folder, index) => {\r\n+    console.log('downloadAttachment called with:', { email: email ? '***@***' : 'missing', password: password ? '***' : 'missing', uid, folder, index });\r\n+\r\n+    try {\r\n+        // First, let's just test if we can connect and get basic mailbox info\r\n+        const client = getClient(email, password);\r\n+\r\n+        console.log('Connecting to IMAP server...');\r\n+        await client.connect();\r\n+        console.log('IMAP connection successful');\r\n+\r\n+        try {\r\n+            console.log('Getting mailbox lock for folder:', folder);\r\n+            let lock = await client.getMailboxLock(folder);\r\n+            console.log('Mailbox lock acquired');\r\n+\r\n+            try {\r\n+                console.log('Fetching message with UID:', uid);\r\n+                // Fetch the specific message with full source\r\n+                const message = await client.fetchOne(uid, { source: true, uid: true });\r\n+                console.log('Message fetched, has source:', !!message.source);\r\n+\r\n+                if (!message || !message.source) {\r\n+                    throw new Error('Message not found');\r\n+                }\r\n+\r\n+                console.log('Parsing email message...');\r\n+                // Parse the email to get attachments\r\n+                const mail = await simpleParser(message.source);\r\n+                console.log('Email parsed, attachments count:', mail.attachments ? mail.attachments.length : 0);\r\n+\r\n+                if (!mail.attachments || mail.attachments.length === 0) {\r\n+                    throw new Error('No attachments found in email');\r\n+                }\r\n+\r\n+                if (index >= mail.attachments.length) {\r\n+                    throw new Error(`Attachment index ${index} out of range (total: ${mail.attachments.length})`);\r\n+                }\r\n+\r\n+                const attachment = mail.attachments[index];\r\n+                console.log('Found attachment:', {\r\n+                    filename: attachment.filename,\r\n+                    size: attachment.size ? attachment.size.length : 0,\r\n+                    contentType: attachment.contentType\r\n+                });\r\n+\r\n+                return {\r\n+                    filename: attachment.filename || `attachment-${index}`,\r\n+                    contentType: attachment.contentType || 'application/octet-stream',\r\n+                    content: attachment.content,\r\n+                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n+                    contentDisposition: attachment.contentDisposition || 'attachment'\r\n+                };\r\n+            } finally {\r\n+                lock.release();\r\n+                console.log('Mailbox lock released');\r\n+            }\r\n+        } finally {\r\n+            await client.logout();\r\n+            console.log('IMAP connection closed');\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('Error in downloadAttachment:', error);\r\n+        // Return a more detailed error for debugging\r\n+        throw new Error(`DownloadAttachment failed: ${error.message}`);\r\n+    }\r\n+};\r\n+\r\n+export { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveSentEmail, saveDraft, downloadAttachment };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1767970704530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,56 +39,18 @@\n     const toemailMatch = mail.to?.text.match(/<([^>]*)>/);\r\n     const toemailName = toemailMatch ? toemailMatch[1] : (mail.to?.text.split('@')[0].trim() || 'Unknown');\r\n     const toemailEmail = toemailMatch ? toemailMatch[1] : (mail.to?.text || '');\r\n \r\n-    // Process attachments without saving to disk - create direct download links\r\n-    const processedAttachments = [];\r\n-    if (mail.attachments && mail.attachments.length > 0) {\r\n-        for (let i = 0; i < mail.attachments.length; i++) {\r\n-            const attachment = mail.attachments[i];\r\n-            try {\r\n-                // Create direct download link using IMAP message data\r\n-                const imapFolder = folder === 'inbox' ? 'INBOX' : folder.toUpperCase();\r\n-                const downloadUrl = `/api/download-attachment?uid=${message.uid}&folder=${imapFolder}&index=${i}&filename=${encodeURIComponent(attachment.filename || `attachment-${i}`)}`;\r\n+    // Categorize email based on sender domain\r\n+    const categorizeEmail = (email) => {\r\n+        if (!email) return 'personal';\r\n \r\n-                processedAttachments.push({\r\n-                    filename: attachment.filename || `attachment-${i}`,\r\n-                    originalFilename: attachment.filename,\r\n-                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n-                    contentType: attachment.contentType,\r\n-                    url: downloadUrl,\r\n-                    contentId: attachment.contentId,\r\n-                    contentDisposition: attachment.contentDisposition,\r\n-                    // Store content as base64 for inline preview if needed\r\n-                    content: attachment.content && attachment.content.length < 1024 * 1024 ? attachment.content.toString('base64') : null,\r\n-                    isInline: attachment.contentDisposition === 'inline'\r\n-                });\r\n-            } catch (error) {\r\n-                console.error('Error processing attachment:', error);\r\n-            }\r\n-        }\r\n-    }\r\n+        const domain = email.toLowerCase().split('@')[1];\r\n+        if (!domain) return 'personal';\r\n \r\n-    return {\r\n-        id: message.uid, // ImapFlow provides UID directly on the message object\r\n-        sender: senderName,\r\n-        senderEmail: senderEmail,\r\n-        to: toemailName,\r\n-        toEmail: toemailEmail,\r\n-        subject: mail.subject,\r\n-        preview: mail.textAsHtml ? mail.textAsHtml.slice(0, 100) : (mail.text ? mail.text.slice(0, 100) : ''),\r\n-        body: mail.html || mail.textAsHtml || mail.text,\r\n-        date: mail.date || message.internalDate,\r\n-        unread: !message.flags.has('\\\\Seen'),\r\n-        flagged: message.flags.has('\\\\Flagged'),\r\n-        categoryColor: '#2D62ED',\r\n-        category: 'personal',\r\n-        attachments: processedAttachments,\r\n-        avatar: '',\r\n-        folder: folder,\r\n-        important: message.flags.has('Important'),\r\n-    };\r\n-};\r\n+        // Work domains (common business domains)\r\n+        const workDomains = ['gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com', 'protonmail.com', 'icloud.com', 'me.com', 'mac.com'];\r\n+        // Promotional domains (common marketing/sender domains)\r\n \r\n // Save sent email to \"Sent\" folder\r\n const saveSentEmail = async (email, password, mailOptions) => {\r\n     const client = getClient(email, password);\r\n"
                },
                {
                    "date": 1767970716801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,8 +63,10 @@\n         } else if (isWorkDomain) {\r\n             return 'work';\r\n         } else {\r\n             // For other domains, check if they look like business domains\r\n+            // Business domains typically have 2-3 parts and no common personal suffixes\r\n+            const parts = domain.split('.');\r\n \r\n // Save sent email to \"Sent\" folder\r\n const saveSentEmail = async (email, password, mailOptions) => {\r\n     const client = getClient(email, password);\r\n"
                },
                {
                    "date": 1767970723022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,8 +66,9 @@\n             // For other domains, check if they look like business domains\r\n             // Business domains typically have 2-3 parts and no common personal suffixes\r\n             const parts = domain.split('.');\r\n             if (parts.length >= 2 && parts.length <= 3 && !domain.includes('gmail') && !domain.includes('yahoo') && !domain.includes('hotmail')) {\r\n+                return 'work';\r\n \r\n // Save sent email to \"Sent\" folder\r\n const saveSentEmail = async (email, password, mailOptions) => {\r\n     const client = getClient(email, password);\r\n"
                }
            ],
            "date": 1767969567044,
            "name": "Commit-0",
            "content": "import { ImapFlow } from 'imapflow';\r\nimport { simpleParser } from 'mailparser';\r\nimport dotenv from 'dotenv';\r\nimport MailComposer from 'nodemailer/lib/mail-composer/index.js';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\ndotenv.config();\r\n\r\n// Helper to create a new client instance\r\n// Note: ImapFlow requires a new instance/connection for distinct lifecycles \r\n// or you must manage a persistent connection carefully. \r\n// Here we follow your pattern of \"Connect -> Do Work -> Disconnect\".\r\nconst getClient = (email, password) => {\r\n    return new ImapFlow({\r\n        host: process.env.IMAP_HOST || 'imap.cybershoora.com', // Use environment variable\r\n        port: parseInt(process.env.IMAP_PORT) || 993,\r\n        secure: process.env.IMAP_SECURE === 'true',\r\n        tls: {\r\n            rejectUnauthorized: false // Matches your previous config\r\n        },\r\n        auth: {\r\n            user: email,\r\n            pass: password,\r\n        },\r\n        logger: true // Enable detailed logging for debugging\r\n    });\r\n};\r\n\r\nconst parseEmail = async (message, source, folder = 'inbox') => {\r\n    // 'source' is the raw email buffer provided by ImapFlow\r\n    const mail = await simpleParser(source);\r\n\r\n    const senderMatch = mail.from?.text.match(/\"([^\"]*)\"/);\r\n    const emailMatch = mail.from?.text.match(/<([^>]*)>/);\r\n    const senderName = senderMatch ? senderMatch[1] : (mail.from?.text.split('<')[0].trim() || 'Unknown');\r\n    const senderEmail = emailMatch ? emailMatch[1] : (mail.from?.text || '');\r\n\r\n    const toemailMatch = mail.to?.text.match(/<([^>]*)>/);\r\n    const toemailName = toemailMatch ? toemailMatch[1] : (mail.to?.text.split('@')[0].trim() || 'Unknown');\r\n    const toemailEmail = toemailMatch ? toemailMatch[1] : (mail.to?.text || '');\r\n\r\n    // Function to categorize email based on sender email address\r\n    const categorizeEmail = (senderEmail, subject = '') => {\r\n        if (!senderEmail) return 'personal';\r\n\r\n        const email = senderEmail.toLowerCase();\r\n        const subjectLower = (subject || '').toLowerCase();\r\n\r\n        // Personal email providers\r\n        const personalDomains = [\r\n            'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\r\n            'icloud.com', 'me.com', 'live.com', 'msn.com', 'protonmail.com',\r\n            'mail.com', 'yandex.com', 'zoho.com'\r\n        ];\r\n\r\n        // Promotional/marketing keywords and domains\r\n        const promotionalKeywords = [\r\n            'newsletter', 'promotion', 'offer', 'deal', 'sale', 'discount',\r\n            'marketing', 'advertisement', 'subscribe', 'unsubscribe'\r\n        ];\r\n\r\n        const promotionalDomains = [\r\n            'mailchimp.com', 'constantcontact.com', 'sendgrid.com',\r\n            'amazon.com', 'ebay.com', 'facebook.com', 'twitter.com',\r\n            'instagram.com', 'linkedin.com', 'pinterest.com'\r\n        ];\r\n\r\n        // Check if it's from a personal email provider\r\n        const emailDomain = email.split('@')[1];\r\n        if (personalDomains.includes(emailDomain)) {\r\n            // Check if it might be promotional despite being from personal domain\r\n            const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n                subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n            );\r\n            if (hasPromotionalKeywords) {\r\n                return 'promotions';\r\n            }\r\n            return 'personal';\r\n        }\r\n\r\n        // Check if it's promotional\r\n        if (promotionalDomains.includes(emailDomain)) {\r\n            return 'promotions';\r\n        }\r\n\r\n        // Check for promotional keywords in subject or sender name\r\n        const hasPromotionalKeywords = promotionalKeywords.some(keyword =>\r\n            subjectLower.includes(keyword) || senderName.toLowerCase().includes(keyword)\r\n        );\r\n        if (hasPromotionalKeywords) {\r\n            return 'promotions';\r\n    const processedAttachments = [];\r\n    if (mail.attachments && mail.attachments.length > 0) {\r\n        for (let i = 0; i < mail.attachments.length; i++) {\r\n            const attachment = mail.attachments[i];\r\n            try {\r\n                // Create direct download link using IMAP message data\r\n                const imapFolder = folder === 'inbox' ? 'INBOX' : folder.toUpperCase();\r\n                const downloadUrl = `/api/download-attachment?uid=${message.uid}&folder=${imapFolder}&index=${i}&filename=${encodeURIComponent(attachment.filename || `attachment-${i}`)}`;\r\n\r\n                processedAttachments.push({\r\n                    filename: attachment.filename || `attachment-${i}`,\r\n                    originalFilename: attachment.filename,\r\n                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n                    contentType: attachment.contentType,\r\n                    url: downloadUrl,\r\n                    contentId: attachment.contentId,\r\n                    contentDisposition: attachment.contentDisposition,\r\n                    // Store content as base64 for inline preview if needed\r\n                    content: attachment.content && attachment.content.length < 1024 * 1024 ? attachment.content.toString('base64') : null,\r\n                    isInline: attachment.contentDisposition === 'inline'\r\n                });\r\n            } catch (error) {\r\n                console.error('Error processing attachment:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        id: message.uid, // ImapFlow provides UID directly on the message object\r\n        sender: senderName,\r\n        senderEmail: senderEmail,\r\n        to: toemailName,\r\n        toEmail: toemailEmail,\r\n        subject: mail.subject,\r\n        preview: mail.textAsHtml ? mail.textAsHtml.slice(0, 100) : (mail.text ? mail.text.slice(0, 100) : ''),\r\n        body: mail.html || mail.textAsHtml || mail.text,\r\n        date: mail.date || message.internalDate,\r\n        unread: !message.flags.has('\\\\Seen'),\r\n        flagged: message.flags.has('\\\\Flagged'),\r\n        categoryColor: '#2D62ED',\r\n        category: 'personal',\r\n        attachments: processedAttachments,\r\n        avatar: '',\r\n        folder: folder,\r\n        important: message.flags.has('Important'),\r\n    };\r\n};\r\n\r\n// Save sent email to \"Sent\" folder\r\nconst saveSentEmail = async (email, password, mailOptions) => {\r\n    const client = getClient(email, password);\r\n\r\n    // 1. Compile the email object into a raw buffer (RFC822 format)\r\n    const composer = new MailComposer(mailOptions);\r\n    const messageBuffer = await composer.compile().build();\r\n\r\n    await client.connect();\r\n\r\n    // 2. Define target folder (Stackmail usually uses \"Sent\")\r\n    const sentFolder = 'Sent';\r\n\r\n    let lock = await client.getMailboxLock(sentFolder);\r\n    try {\r\n        // 3. Append the message with the \\Seen flag so it appears read\r\n        await client.append(sentFolder, messageBuffer, ['\\\\Seen']);\r\n    } catch (err) {\r\n        // Optional: Retry with \"Sent Items\" if \"Sent\" fails\r\n    } finally {\r\n        lock.release();\r\n    }\r\n\r\n    await client.logout();\r\n};\r\n\r\n//fetch inbox\r\nconst fetchInbox = async (email, password, page = 1, limit = 10) => {\r\n    const client = getClient(email, password);\r\n    const parsedMails = [];\r\n    let status;\r\n\r\n    await client.connect();\r\n\r\n    // We must lock the mailbox to perform operations\r\n    let lock = await client.getMailboxLock('INBOX');\r\n    try {\r\n        // Force refresh mailbox by selecting it explicitly to get latest status\r\n        await client.mailboxOpen('INBOX', { readOnly: true });\r\n        await client.noop();\r\n\r\n        // 1. Get status to find out how many messages are there\r\n        status = await client.status('INBOX', { messages: true });\r\n        const total = status.messages;\r\n\r\n        // 2. Calculate pagination using UIDs for reliability\r\n        const offset = (page - 1) * limit;\r\n        const start = Math.max(1, total - offset - limit + 1);\r\n        const end = Math.min(total, total - offset);\r\n        const range = total > 0 ? `${start}:${end}` : '';\r\n\r\n        if (total > 0 && start <= end) {\r\n            // 3. Fetch specific range using sequence numbers but get UID info\r\n            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n                const parsed = await parseEmail(message, message.source);\r\n                parsedMails.push(parsed);\r\n            }\r\n        }\r\n    } finally {\r\n        // Always release lock\r\n        lock.release();\r\n    }\r\n\r\n    await client.logout();\r\n\r\n    const emailUser = email.split('@')[0];\r\n    const userName = emailUser.split('.').map(name => name.charAt(0).toUpperCase() + name.slice(1)).join(' ');\r\n\r\n    // Reverse to show newest first\r\n    return {\r\n        userName,\r\n        mails: parsedMails.reverse(),\r\n        pagination: {\r\n            page,\r\n            limit,\r\n            total: status.messages,\r\n            hasNext: page * limit < status.messages,\r\n            hasPrev: page > 1\r\n        }\r\n    };\r\n};\r\n\r\nconst fetchEmailsByFolder = async (email, password, folder, page = 1, limit = 20) => {\r\n    const client = getClient(email, password);\r\n    const parsedMails = [];\r\n    let status;\r\n\r\n    await client.connect();\r\n\r\n    let lock = await client.getMailboxLock(folder);\r\n    try {\r\n        status = await client.status(folder, { messages: true });\r\n        const total = status.messages;\r\n\r\n        // Calculate pagination\r\n        const offset = (page - 1) * limit;\r\n        const start = Math.max(1, total - offset - limit + 1);\r\n        const end = Math.min(total, total - offset);\r\n        const range = total > 0 ? `${start}:${end}` : '';\r\n\r\n        if (total > 0 && start <= end) {\r\n            for await (let message of client.fetch(range, { envelope: true, source: true, uid: true, flags: true, internalDate: true })) {\r\n                const parsed = await parseEmail(message, message.source, folder);\r\n                parsedMails.push(parsed);\r\n            }\r\n        }\r\n    } catch (err) {\r\n    } finally {\r\n        lock.release();\r\n    }\r\n\r\n    await client.logout();\r\n\r\n    return {\r\n        folder,\r\n        mails: parsedMails.reverse(),\r\n        pagination: {\r\n            page,\r\n            limit,\r\n            total: status.messages,\r\n            hasNext: page * limit < status.messages,\r\n            hasPrev: page > 1\r\n        }\r\n    };\r\n};\r\n\r\nconst markAsRead = async (email, password, messageId, read) => {\r\n    const client = getClient(email, password);\r\n    await client.connect();\r\n\r\n    let lock = await client.getMailboxLock('INBOX');\r\n    try {\r\n        // 'uid: true' is crucial because we are passing a UID, not a sequence number\r\n        if (read) {\r\n            await client.messageFlagsAdd(messageId, ['\\\\Seen'], { uid: true });\r\n        } else {\r\n            await client.messageFlagsRemove(messageId, ['\\\\Seen'], { uid: true });\r\n        }\r\n    } finally {\r\n        lock.release();\r\n    }\r\n\r\n    await client.logout();\r\n};\r\n\r\nconst saveDraft = async (email, password, draftData) => {\r\n    const client = getClient(email, password);\r\n\r\n    // Defensively ensure draftData is an object to prevent errors if it's null or undefined.\r\n    const data = draftData || {};\r\n\r\n    // 1. Map your frontend data to Nodemailer structure\r\n    const mailOptions = {\r\n        from: email,\r\n        to: data.to,\r\n        subject: data.subject,\r\n        text: data.body, // or data.text depending on your frontend\r\n        html: data.html || (data.body ? `<p>${data.body}</p>` : '') // A more robust fallback to avoid \"<p>undefined</p>\"\r\n    };\r\n\r\n    // 2. Compile into raw email buffer\r\n    const composer = new MailComposer(mailOptions);\r\n    const messageBuffer = await composer.compile().build();\r\n\r\n    await client.connect();\r\n\r\n    // 3. Determine Drafts Folder\r\n    // Common names: 'Drafts', 'Draft', '[Gmail]/Drafts'\r\n    // You can also look it up via client.list() if needed\r\n    const draftFolder = 'Drafts';\r\n\r\n    let lock = await client.getMailboxLock(draftFolder);\r\n    try {\r\n        // 4. Append to Drafts folder\r\n        // We add \\Seen (so it doesn't look like a new unread mail)\r\n        // We add \\Draft (standard IMAP flag for drafts)\r\n        await client.append(draftFolder, messageBuffer, ['\\\\Seen', '\\\\Draft']);\r\n    } catch (err) {\r\n        throw err; // Re-throw so your API knows it failed\r\n    } finally {\r\n        lock.release();\r\n    }\r\n\r\n    await client.logout();\r\n    return { success: true };\r\n};\r\n\r\n// Don't forget to export it!\r\nconst toggleStarred = async (email, password, messageId, starred) => {\r\n    const client = getClient(email, password);\r\n    await client.connect();\r\n\r\n    let lock = await client.getMailboxLock('INBOX');\r\n    try {\r\n        if (starred) {\r\n            await client.messageFlagsAdd(messageId, ['\\\\Flagged'], { uid: true });\r\n        } else {\r\n            await client.messageFlagsRemove(messageId, ['\\\\Flagged'], { uid: true });\r\n        }\r\n    } finally {\r\n        lock.release();\r\n    }\r\n\r\n    await client.logout();\r\n};\r\n\r\nconst toggleImportant = async (email, password, messageId, important) => {\r\n    const client = getClient(email, password);\r\n    await client.connect();\r\n\r\n    let lock = await client.getMailboxLock('INBOX');\r\n    try {\r\n        if (important) {\r\n            await client.messageFlagsAdd(messageId, ['Important'], { uid: true });\r\n        } else {\r\n            await client.messageFlagsRemove(messageId, ['Important'], { uid: true });\r\n        }\r\n    } finally {\r\n        lock.release();\r\n    }\r\n\r\n    await client.logout();\r\n};\r\nconst deleteEmail = async (email, password, messageId, folder = 'INBOX') => {\r\n    const client = getClient(email, password);\r\n    await client.connect();\r\n\r\n    let lock = await client.getMailboxLock(folder);\r\n    try {\r\n        // Mark as deleted\r\n        await client.messageFlagsAdd(messageId, ['\\\\Deleted'], { uid: true });\r\n        // Expunge/Delete is handled by messageDelete in ImapFlow or implies expunge depending on server\r\n        // Using messageDelete is the safest explicit way to remove by UID\r\n        await client.messageDelete(messageId, { uid: true });\r\n\r\n    } finally {\r\n        lock.release();\r\n    }\r\n\r\n    await client.logout();\r\n};\r\n\r\nconst moveEmail = async (email, password, messageId, destinationFolder, sourceFolder = 'INBOX') => {\r\n    const client = getClient(email, password);\r\n    await client.connect();\r\n\r\n    let lock = await client.getMailboxLock(sourceFolder);\r\n    try {\r\n        // messageMove returns a result object, true usually implies success\r\n        await client.messageMove(messageId, destinationFolder, { uid: true });\r\n    } finally {\r\n        lock.release();\r\n    }\r\n\r\n    await client.logout();\r\n};\r\n\r\nconst downloadAttachment = async (email, password, uid, folder, index) => {\r\n    console.log('downloadAttachment called with:', { email: email ? '***@***' : 'missing', password: password ? '***' : 'missing', uid, folder, index });\r\n\r\n    try {\r\n        // First, let's just test if we can connect and get basic mailbox info\r\n        const client = getClient(email, password);\r\n\r\n        console.log('Connecting to IMAP server...');\r\n        await client.connect();\r\n        console.log('IMAP connection successful');\r\n\r\n        try {\r\n            console.log('Getting mailbox lock for folder:', folder);\r\n            let lock = await client.getMailboxLock(folder);\r\n            console.log('Mailbox lock acquired');\r\n\r\n            try {\r\n                console.log('Fetching message with UID:', uid);\r\n                // Fetch the specific message with full source\r\n                const message = await client.fetchOne(uid, { source: true, uid: true });\r\n                console.log('Message fetched, has source:', !!message.source);\r\n\r\n                if (!message || !message.source) {\r\n                    throw new Error('Message not found');\r\n                }\r\n\r\n                console.log('Parsing email message...');\r\n                // Parse the email to get attachments\r\n                const mail = await simpleParser(message.source);\r\n                console.log('Email parsed, attachments count:', mail.attachments ? mail.attachments.length : 0);\r\n\r\n                if (!mail.attachments || mail.attachments.length === 0) {\r\n                    throw new Error('No attachments found in email');\r\n                }\r\n\r\n                if (index >= mail.attachments.length) {\r\n                    throw new Error(`Attachment index ${index} out of range (total: ${mail.attachments.length})`);\r\n                }\r\n\r\n                const attachment = mail.attachments[index];\r\n                console.log('Found attachment:', {\r\n                    filename: attachment.filename,\r\n                    size: attachment.size ? attachment.size.length : 0,\r\n                    contentType: attachment.contentType\r\n                });\r\n\r\n                return {\r\n                    filename: attachment.filename || `attachment-${index}`,\r\n                    contentType: attachment.contentType || 'application/octet-stream',\r\n                    content: attachment.content,\r\n                    size: attachment.size || (attachment.content ? attachment.content.length : 0),\r\n                    contentDisposition: attachment.contentDisposition || 'attachment'\r\n                };\r\n            } finally {\r\n                lock.release();\r\n                console.log('Mailbox lock released');\r\n            }\r\n        } finally {\r\n            await client.logout();\r\n            console.log('IMAP connection closed');\r\n        }\r\n    } catch (error) {\r\n        console.error('Error in downloadAttachment:', error);\r\n        // Return a more detailed error for debugging\r\n        throw new Error(`DownloadAttachment failed: ${error.message}`);\r\n    }\r\n};\r\n\r\nexport { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveSentEmail, saveDraft, downloadAttachment };"
        }
    ]
}