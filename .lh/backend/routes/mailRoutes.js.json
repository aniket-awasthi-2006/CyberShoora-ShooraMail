{
    "sourceFile": "backend/routes/mailRoutes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1767974339444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767974353216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,10 +200,9 @@\n             // We don't want to tell the frontend \"Failed\" just because the copy wasn't saved.\r\n             console.error('Error saving sent email copy:', err);\r\n         }\r\n     }\r\n-}\r\n-);\r\n+});\r\n \r\n // Reply to Email\r\n router.post('/reply-mail', async (req, res) => {\r\n     const { email, password, to, subject, body, html, originalMessageId } = req.body;\r\n"
                },
                {
                    "date": 1767974373116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,10 +126,11 @@\n     }\r\n });\r\n \r\n // Send Email\r\n-router.post('/send-mail', async (req, res) => {\r\n-    const { email, password, to, subject, body, html, attachments } = req.body;\r\n+router.post('/send-mail', upload.fields([{ name: 'attachments', maxCount: 10 }]), async (req, res) => {\r\n+    const { email, password, to, subject, body, html } = req.body;\r\n+    const attachments = req.files?.attachments || [];\r\n     try {\r\n         // Always send HTML content - if html is provided use it, otherwise convert body to HTML\r\n         const htmlContent = html || `<div>${body}</div>`;\r\n \r\n"
                },
                {
                    "date": 1767974394264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -136,38 +136,13 @@\n \r\n         // Process attachments for nodemailer\r\n         let processedAttachments = [];\r\n         if (attachments && Array.isArray(attachments)) {\r\n-            processedAttachments = attachments.map(attachment => {\r\n-                if (attachment.path) {\r\n-                    // File was uploaded to server\r\n-                    return {\r\n-                        path: attachment.path,\r\n-                        filename: attachment.filename,\r\n-                        contentType: attachment.mimetype\r\n-                    };\r\n-                } else if (attachment.content) {\r\n-                    // Base64 encoded content\r\n-                    return {\r\n-                        content: attachment.content,\r\n-                        filename: attachment.filename,\r\n-                        contentType: attachment.mimetype,\r\n-                        encoding: 'base64'\r\n-                    };\r\n-                } else if (attachment.url) {\r\n-                    // URL-based attachment\r\n-                    return {\r\n-                        path: attachment.url.startsWith('http') ? attachment.url : path.join(process.cwd(), attachment.url),\r\n-                        filename: attachment.filename,\r\n-                        contentType: attachment.mimetype\r\n-                    };\r\n-                }\r\n-                return {\r\n-                    path: attachment.path || attachment.url,\r\n-                    filename: attachment.filename,\r\n-                    contentType: attachment.mimetype\r\n-                };\r\n-            });\r\n+            processedAttachments = attachments.map(attachment => ({\r\n+                path: attachment.path,\r\n+                filename: attachment.originalname,\r\n+                contentType: attachment.mimetype\r\n+            }));\r\n         }\r\n \r\n         await sendEmail(\r\n             { user: email, pass: password },\r\n"
                },
                {
                    "date": 1767975187049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,16 +27,24 @@\n         fileSize: 10 * 1024 * 1024, // 10MB limit\r\n     },\r\n     fileFilter: (req, file, cb) => {\r\n         // Allow common file types\r\n-        const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx|txt|zip|rar/;\r\n-        const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());\r\n-        const mimetype = allowedTypes.test(file.mimetype);\r\n+        const allowedExtensions = ['.jpeg', '.jpg', '.png', '.gif', '.pdf', '.doc', '.docx', '.txt', '.zip', '.rar'];\r\n+        const allowedMimeTypes = [\r\n+            'image/jpeg', 'image/jpg', 'image/png', 'image/gif',\r\n+            'application/pdf',\r\n+            'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n+            'text/plain',\r\n+            'application/zip', 'application/x-rar-compressed'\r\n+        ];\r\n \r\n-        if (mimetype && extname) {\r\n+        const extname = path.extname(file.originalname).toLowerCase();\r\n+        const mimetype = file.mimetype.toLowerCase();\r\n+\r\n+        if (allowedExtensions.includes(extname) && allowedMimeTypes.includes(mimetype)) {\r\n             return cb(null, true);\r\n         } else {\r\n-            cb(new Error('Invalid file type'));\r\n+            cb(new Error(`Invalid file type. Extension: ${extname}, MIME: ${mimetype}`));\r\n         }\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1767975466242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,10 +133,33 @@\n         res.status(500).json({ success: false, message: \"Failed to fetch folder emails\" });\r\n     }\r\n });\r\n \r\n+// Send Email with error handling middleware\r\n+const handleMulterError = (error, req, res, next) => {\r\n+    if (error instanceof multer.MulterError) {\r\n+        if (error.code === 'LIMIT_FILE_SIZE') {\r\n+            return res.status(400).json({ success: false, message: \"File size exceeds 10MB limit\" });\r\n+        }\r\n+        if (error.code === 'LIMIT_FILE_COUNT') {\r\n+            return res.status(400).json({ success: false, message: \"Maximum 10 attachments allowed\" });\r\n+        }\r\n+        if (error.code === 'LIMIT_UNEXPECTED_FILE') {\r\n+            return res.status(400).json({ success: false, message: \"Unexpected file field\" });\r\n+        }\r\n+        return res.status(400).json({ success: false, message: `Upload error: ${error.message}` });\r\n+    }\r\n+\r\n+    // Handle custom file filter errors\r\n+    if (error.message && error.message.includes('Invalid file type')) {\r\n+        return res.status(400).json({ success: false, message: error.message });\r\n+    }\r\n+\r\n+    next(error);\r\n+};\r\n+\r\n // Send Email\r\n-router.post('/send-mail', upload.fields([{ name: 'attachments', maxCount: 10 }]), async (req, res) => {\r\n+router.post('/send-mail', upload.fields([{ name: 'attachments', maxCount: 10 }]), handleMulterError, async (req, res) => {\r\n     const { email, password, to, subject, body, html } = req.body;\r\n     const attachments = req.files?.attachments || [];\r\n     try {\r\n         // Always send HTML content - if html is provided use it, otherwise convert body to HTML\r\n"
                },
                {
                    "date": 1767975494318,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -160,9 +160,17 @@\n // Send Email\r\n router.post('/send-mail', upload.fields([{ name: 'attachments', maxCount: 10 }]), handleMulterError, async (req, res) => {\r\n     const { email, password, to, subject, body, html } = req.body;\r\n     const attachments = req.files?.attachments || [];\r\n+    let emailSent = false;\r\n+\r\n     try {\r\n+        // Validate required fields\r\n+        if (!to || !subject || (!body && !html)) {\r\n+            cleanupUploadedFiles(attachments);\r\n+            return res.status(400).json({ success: false, message: \"Missing required fields: to, subject, and body/html\" });\r\n+        }\r\n+\r\n         // Always send HTML content - if html is provided use it, otherwise convert body to HTML\r\n         const htmlContent = html || `<div>${body}</div>`;\r\n \r\n         // Process attachments for nodemailer\r\n@@ -178,35 +186,41 @@\n         await sendEmail(\r\n             { user: email, pass: password },\r\n             { from: email, to, subject, html: htmlContent, text: body, attachments: processedAttachments }\r\n         );\r\n+        emailSent = true;\r\n         res.status(200).json({ success: true, message: \"Email Sent Successfully\" });\r\n     } catch (error) {\r\n-        res.status(500).json({ success: false, message: error.message });\r\n+        console.error('Email sending error:', error);\r\n+        cleanupUploadedFiles(attachments);\r\n+        res.status(500).json({ success: false, message: error.message || \"Failed to send email\" });\r\n     } finally {\r\n-        try {\r\n-            const htmlContent = html || `<div>${body}</div>`;\r\n+        // Only try to save sent email if it was actually sent\r\n+        if (emailSent) {\r\n+            try {\r\n+                const htmlContent = html || `<div>${body}</div>`;\r\n \r\n-            // Process attachments for saving sent email\r\n-            let processedAttachments = [];\r\n-            if (attachments && Array.isArray(attachments)) {\r\n-                processedAttachments = attachments.map(attachment => ({\r\n-                    filename: attachment.filename,\r\n-                    size: attachment.size,\r\n-                    mimetype: attachment.mimetype,\r\n-                    url: attachment.url\r\n-                }));\r\n+                // Process attachments for saving sent email\r\n+                let processedAttachments = [];\r\n+                if (attachments && Array.isArray(attachments)) {\r\n+                    processedAttachments = attachments.map(attachment => ({\r\n+                        filename: attachment.filename,\r\n+                        size: attachment.size,\r\n+                        mimetype: attachment.mimetype,\r\n+                        url: attachment.url\r\n+                    }));\r\n+                }\r\n+\r\n+                await saveSentEmail(\r\n+                    email, // Assuming authDetails has the email/user\r\n+                    password, // Assuming authDetails has the password\r\n+                    { from: email, to, subject, html: htmlContent, text: body, attachments: processedAttachments }\r\n+                );\r\n+            } catch (err) {\r\n+                // We log the error but don't throw it, because the email WAS actually sent to the recipient.\r\n+                // We don't want to tell the frontend \"Failed\" just because the copy wasn't saved.\r\n+                console.error('Error saving sent email copy:', err);\r\n             }\r\n-\r\n-            await saveSentEmail(\r\n-                email, // Assuming authDetails has the email/user\r\n-                password, // Assuming authDetails has the password\r\n-                { from: email, to, subject, html: htmlContent, text: body, attachments: processedAttachments }\r\n-            );\r\n-        } catch (err) {\r\n-            // We log the error but don't throw it, because the email WAS actually sent to the recipient.\r\n-            // We don't want to tell the frontend \"Failed\" just because the copy wasn't saved.\r\n-            console.error('Error saving sent email copy:', err);\r\n         }\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1767975516249,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,30 @@\n import express from 'express';\r\n import multer from 'multer';\r\n import path from 'path';\r\n import { fileURLToPath } from 'url';\r\n+import fs from 'fs';\r\n import { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveDraft, saveSentEmail, downloadAttachment } from '../services/imapService.js';\r\n import { sendEmail, replyEmail, forwardEmail } from '../services/smtpService.js';\r\n \r\n const router = express.Router();\r\n \r\n+// Utility function to clean up uploaded files\r\n+const cleanupUploadedFiles = (attachments) => {\r\n+    if (attachments && Array.isArray(attachments)) {\r\n+        attachments.forEach(attachment => {\r\n+            if (attachment.path && fs.existsSync(attachment.path)) {\r\n+                try {\r\n+                    fs.unlinkSync(attachment.path);\r\n+                    console.log(`Cleaned up file: ${attachment.path}`);\r\n+                } catch (err) {\r\n+                    console.error(`Failed to cleanup file ${attachment.path}:`, err);\r\n+                }\r\n+            }\r\n+        });\r\n+    }\r\n+};\r\n+\r\n // Configure multer for file uploads\r\n const __filename = fileURLToPath(import.meta.url);\r\n const __dirname = path.dirname(__filename);\r\n \r\n"
                },
                {
                    "date": 1767975567112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -205,8 +205,11 @@\n             { from: email, to, subject, html: htmlContent, text: body, attachments: processedAttachments }\r\n         );\r\n         emailSent = true;\r\n         res.status(200).json({ success: true, message: \"Email Sent Successfully\" });\r\n+\r\n+        // Schedule cleanup after successful send\r\n+        cleanupAfterSend(attachments);\r\n     } catch (error) {\r\n         console.error('Email sending error:', error);\r\n         cleanupUploadedFiles(attachments);\r\n         res.status(500).json({ success: false, message: error.message || \"Failed to send email\" });\r\n"
                },
                {
                    "date": 1767975660853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -152,8 +152,12 @@\n });\r\n \r\n // Send Email with error handling middleware\r\n const handleMulterError = (error, req, res, next) => {\r\n+    // Clean up any uploaded files on error\r\n+    const attachments = req.files?.attachments || [];\r\n+    cleanupUploadedFiles(attachments);\r\n+\r\n     if (error instanceof multer.MulterError) {\r\n         if (error.code === 'LIMIT_FILE_SIZE') {\r\n             return res.status(400).json({ success: false, message: \"File size exceeds 10MB limit\" });\r\n         }\r\n"
                },
                {
                    "date": 1767975685125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,9 +211,9 @@\n         emailSent = true;\r\n         res.status(200).json({ success: true, message: \"Email Sent Successfully\" });\r\n \r\n         // Schedule cleanup after successful send\r\n-        cleanupAfterSend(attachments);\r\n+        setTimeout(() => cleanupUploadedFiles(attachments), 1000); // Delay cleanup to ensure email is sent\r\n     } catch (error) {\r\n         console.error('Email sending error:', error);\r\n         cleanupUploadedFiles(attachments);\r\n         res.status(500).json({ success: false, message: error.message || \"Failed to send email\" });\r\n"
                },
                {
                    "date": 1767975815431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,11 +27,17 @@\n // Configure multer for file uploads\r\n const __filename = fileURLToPath(import.meta.url);\r\n const __dirname = path.dirname(__filename);\r\n \r\n+// Ensure uploads directory exists\r\n+const uploadsDir = path.join(__dirname, '../uploads');\r\n+if (!fs.existsSync(uploadsDir)) {\r\n+    fs.mkdirSync(uploadsDir, { recursive: true });\r\n+}\r\n+\r\n const storage = multer.diskStorage({\r\n     destination: (req, file, cb) => {\r\n-        cb(null, path.join(__dirname, '../uploads'));\r\n+        cb(null, uploadsDir);\r\n     },\r\n     filename: (req, file, cb) => {\r\n         const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\n         cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\r\n"
                },
                {
                    "date": 1767975916989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -226,9 +226,9 @@\n     } finally {\r\n         // Only try to save sent email if it was actually sent\r\n         if (emailSent) {\r\n             try {\r\n-                const htmlContent = html || `<div>${body}</div>`;\r\n+                const htmlContent = htsml || `<div>${body}</div>`;\r\n \r\n                 // Process attachments for saving sent email\r\n                 let processedAttachments = [];\r\n                 if (attachments && Array.isArray(attachments)) {\r\n"
                },
                {
                    "date": 1767976316564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,10 @@\n+import express from 'express';\r\n+import multer from 'multer';\r\n+import path from 'path';\r\n+import fs from 'fs';\r\n+import { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveDraft, saveSentEmail, downloadAttachment } from '../services/imapService.js';\r\n+import { sendEmail, replyEmail, forwardEmail } from '../services/smtpService.js';\r\n \r\n const storage = multer.diskStorage({\r\n     destination: (req, file, cb) => {\r\n         cb(null, uploadsDir);\r\n"
                }
            ],
            "date": 1767974339444,
            "name": "Commit-0",
            "content": "import express from 'express';\r\nimport multer from 'multer';\r\nimport path from 'path';\r\nimport { fileURLToPath } from 'url';\r\nimport { fetchInbox, fetchEmailsByFolder, markAsRead, deleteEmail, moveEmail, toggleStarred, toggleImportant, saveDraft, saveSentEmail, downloadAttachment } from '../services/imapService.js';\r\nimport { sendEmail, replyEmail, forwardEmail } from '../services/smtpService.js';\r\n\r\nconst router = express.Router();\r\n\r\n// Configure multer for file uploads\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nconst storage = multer.diskStorage({\r\n    destination: (req, file, cb) => {\r\n        cb(null, path.join(__dirname, '../uploads'));\r\n    },\r\n    filename: (req, file, cb) => {\r\n        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\n        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\r\n    }\r\n});\r\n\r\nconst upload = multer({\r\n    storage: storage,\r\n    limits: {\r\n        fileSize: 10 * 1024 * 1024, // 10MB limit\r\n    },\r\n    fileFilter: (req, file, cb) => {\r\n        // Allow common file types\r\n        const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx|txt|zip|rar/;\r\n        const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());\r\n        const mimetype = allowedTypes.test(file.mimetype);\r\n\r\n        if (mimetype && extname) {\r\n            return cb(null, true);\r\n        } else {\r\n            cb(new Error('Invalid file type'));\r\n        }\r\n    }\r\n});\r\n\r\n// Login and Fetch Initial Emails\r\nrouter.post('/login-fetch', async (req, res) => {\r\n    const { email, password } = req.body;\r\n\r\n    try {\r\n        const emails = await fetchInbox(email, password, 1, 10);\r\n\r\n        // Send Welcome Mail (Fire and forget)\r\n        const welcomeHtml = `\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Image Email</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            padding: 0;\r\n            background-color: #f4f4f4;\r\n        }\r\n        .email-container {\r\n            width: 100%;\r\n            margin: 0;\r\n            padding: 0;\r\n        }\r\n        .responsive-image {\r\n            width: 100%;\r\n            height: auto;\r\n            display: block;\r\n            border-radius: 10px;\r\n            -webkit-border-radius: 10px;\r\n            -moz-border-radius: 10px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"email-container\">\r\n        <img src=\"https://res.cloudinary.com/dtwumvj5i/image/upload/v1767200085/Mail_Image_iwjmp1.jpg\" \r\n             alt=\"Mail Image\" \r\n             class=\"responsive-image\">\r\n    </div>\r\n</body>\r\n</html>\r\n        `;\r\n\r\n        sendEmail(\r\n            null,\r\n            {\r\n                from: `Shoora Mail <${process.env.SITE_EMAIL}>`,\r\n                to: email,\r\n                subject: 'Welcome to Shoora Mail! ðŸš€',\r\n                html: welcomeHtml,\r\n                text: 'Welcome to Shoora Mail! You have successfully logged in.',\r\n            }\r\n        ).catch(err => { });\r\n        res.status(200).json({ success: true, data: emails });\r\n    } catch (error) {\r\n        res.status(401).json({ success: false, message: \"Invalid Credentials or Connection Failed\" });\r\n    }\r\n});\r\n\r\n// Fetch Inbox Emails\r\nrouter.post('/inbox-fetch', async (req, res) => {\r\n    const { email, password, page = 1, limit = 10 } = req.body;\r\n\r\n    try {\r\n        const emails = await fetchInbox(email, password, parseInt(page), parseInt(limit));\r\n        res.status(200).json({ success: true, data: emails });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: \"Failed to fetch inbox\" });\r\n    }\r\n});\r\n\r\n// Fetch Emails by Folder\r\nrouter.post('/folder-fetch', async (req, res) => {\r\n    const { email, password, folder, page = 1, limit = 10 } = req.body;\r\n\r\n    try {\r\n        const emails = await fetchEmailsByFolder(email, password, folder, parseInt(page), parseInt(limit));\r\n        res.status(200).json({ success: true, data: emails });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: \"Failed to fetch folder emails\" });\r\n    }\r\n});\r\n\r\n// Send Email\r\nrouter.post('/send-mail', async (req, res) => {\r\n    const { email, password, to, subject, body, html, attachments } = req.body;\r\n    try {\r\n        // Always send HTML content - if html is provided use it, otherwise convert body to HTML\r\n        const htmlContent = html || `<div>${body}</div>`;\r\n\r\n        // Process attachments for nodemailer\r\n        let processedAttachments = [];\r\n        if (attachments && Array.isArray(attachments)) {\r\n            processedAttachments = attachments.map(attachment => {\r\n                if (attachment.path) {\r\n                    // File was uploaded to server\r\n                    return {\r\n                        path: attachment.path,\r\n                        filename: attachment.filename,\r\n                        contentType: attachment.mimetype\r\n                    };\r\n                } else if (attachment.content) {\r\n                    // Base64 encoded content\r\n                    return {\r\n                        content: attachment.content,\r\n                        filename: attachment.filename,\r\n                        contentType: attachment.mimetype,\r\n                        encoding: 'base64'\r\n                    };\r\n                } else if (attachment.url) {\r\n                    // URL-based attachment\r\n                    return {\r\n                        path: attachment.url.startsWith('http') ? attachment.url : path.join(process.cwd(), attachment.url),\r\n                        filename: attachment.filename,\r\n                        contentType: attachment.mimetype\r\n                    };\r\n                }\r\n                return {\r\n                    path: attachment.path || attachment.url,\r\n                    filename: attachment.filename,\r\n                    contentType: attachment.mimetype\r\n                };\r\n            });\r\n        }\r\n\r\n        await sendEmail(\r\n            { user: email, pass: password },\r\n            { from: email, to, subject, html: htmlContent, text: body, attachments: processedAttachments }\r\n        );\r\n        res.status(200).json({ success: true, message: \"Email Sent Successfully\" });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: error.message });\r\n    } finally {\r\n        try {\r\n            const htmlContent = html || `<div>${body}</div>`;\r\n\r\n            // Process attachments for saving sent email\r\n            let processedAttachments = [];\r\n            if (attachments && Array.isArray(attachments)) {\r\n                processedAttachments = attachments.map(attachment => ({\r\n                    filename: attachment.filename,\r\n                    size: attachment.size,\r\n                    mimetype: attachment.mimetype,\r\n                    url: attachment.url\r\n                }));\r\n            }\r\n\r\n            await saveSentEmail(\r\n                email, // Assuming authDetails has the email/user\r\n                password, // Assuming authDetails has the password\r\n                { from: email, to, subject, html: htmlContent, text: body, attachments: processedAttachments }\r\n            );\r\n        } catch (err) {\r\n            // We log the error but don't throw it, because the email WAS actually sent to the recipient.\r\n            // We don't want to tell the frontend \"Failed\" just because the copy wasn't saved.\r\n            console.error('Error saving sent email copy:', err);\r\n        }\r\n    }\r\n}\r\n);\r\n\r\n// Reply to Email\r\nrouter.post('/reply-mail', async (req, res) => {\r\n    const { email, password, to, subject, body, html, originalMessageId } = req.body;\r\n    try {\r\n        // Always send HTML content - if html is provided use it, otherwise convert body to HTML\r\n        const htmlContent = html || `<div>${body}</div>`;\r\n\r\n        await replyEmail(\r\n            { user: email, pass: password },\r\n            { from: email, to, subject, html: htmlContent, text: body, inReplyTo: originalMessageId }\r\n        );\r\n        res.status(200).json({ success: true, message: \"Reply Sent Successfully\" });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: error.message });\r\n    }\r\n});\r\n\r\n// Forward Email\r\nrouter.post('/forward-mail', async (req, res) => {\r\n    const { email, password, to, subject, body, html } = req.body;\r\n    try {\r\n        // Always send HTML content - if html is provided use it, otherwise convert body to HTML\r\n        const htmlContent = html || `<div>${body}</div>`;\r\n\r\n        await forwardEmail(\r\n            { user: email, pass: password },\r\n            { from: email, to, subject, html: htmlContent, text: body }\r\n        );\r\n        res.status(200).json({ success: true, message: \"Email Forwarded Successfully\" });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: error.message });\r\n    }\r\n});\r\n\r\n// Mark Email as Read/Unread\r\nrouter.post('/mark-read', async (req, res) => {\r\n    const { email, password, messageId, read } = req.body;\r\n    try {\r\n        await markAsRead(email, password, messageId, read);\r\n        res.status(200).json({ success: true, message: `Email marked as ${read ? 'read' : 'unread'}` });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: \"Failed to mark email\" });\r\n    }\r\n});\r\n\r\n//toggle-star\r\nrouter.post('/toggle-star', async (req, res) => {\r\n    const { email, password, messageId, starred } = req.body;\r\n    try {\r\n        await toggleStarred(email, password, messageId, starred);\r\n        res.status(200).json({ success: true, message: `Email marked as ${starred ? 'starred' : 'unstarred'}` });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: \"Failed to mark email\" });\r\n    }\r\n});\r\n\r\n//toggle-important\r\nrouter.post('/toggle-important', async (req, res) => {\r\n    const { email, password, messageId, important } = req.body;\r\n    try {\r\n        await toggleImportant(email, password, messageId, important);\r\n        res.status(200).json({ success: true, message: `Email marked as ${important ? 'important' : 'unimportant'}` });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: \"Failed to mark email\" });\r\n    }\r\n});\r\n\r\n//save-draft\r\nrouter.post('/save-draft', async (req, res) => {\r\n    try {\r\n        // The error indicates the nested `composeData` object is not being received.\r\n        // This is likely because the frontend is sending a flat object, similar to other endpoints.\r\n        // We'll destructure the properties directly from the body for consistency.\r\n        const { email, password, to, subject, body, html } = req.body;\r\n\r\n        // Only save draft if there's actual content\r\n        if (!to && !subject && !body && !html) {\r\n            return res.json({ success: true, message: 'No content to save' });\r\n        }\r\n\r\n        await saveDraft(email, password, { to, subject, body, html });\r\n        res.json({ success: true, message: 'Draft saved successfully' });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, error: 'Failed to save draft' });\r\n        console.error('Error saving draft:', error);\r\n    }\r\n});\r\n\r\n\r\n// Delete Email\r\nrouter.post('/delete-mail', async (req, res) => {\r\n    const { email, password, messageId, folder } = req.body;\r\n    try {\r\n        await deleteEmail(email, password, messageId, folder || 'INBOX');\r\n        res.status(200).json({ success: true, message: \"Email deleted successfully\" });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: \"Failed to delete email\" });\r\n    }\r\n});\r\n\r\n// Move Email to Folder\r\nrouter.post('/move-mail', async (req, res) => {\r\n    const { email, password, messageId, destinationFolder, sourceFolder } = req.body;\r\n    try {\r\n        await moveEmail(email, password, messageId, destinationFolder, sourceFolder);\r\n        res.status(200).json({ success: true, message: \"Email moved successfully\" });\r\n    } catch (error) {\r\n        res.status(500).json({ success: false, message: \"Failed to move email\" });\r\n    }\r\n});\r\n\r\n// Test IMAP Connection\r\nrouter.post('/test-imap', async (req, res) => {\r\n    const { email, password } = req.body;\r\n\r\n    console.log('Testing IMAP connection for:', email ? '***@***' : 'missing');\r\n\r\n    if (!email || !password) {\r\n        return res.status(400).json({ success: false, message: \"Email and password required\" });\r\n    }\r\n\r\n    try {\r\n        // Import getClient directly\r\n        const { ImapFlow } = await import('imapflow');\r\n        const dotenv = await import('dotenv');\r\n        dotenv.config();\r\n\r\n        const client = new ImapFlow({\r\n            host: process.env.IMAP_HOST || 'imap.cybershoora.com',\r\n            port: parseInt(process.env.IMAP_PORT) || 993,\r\n            secure: process.env.IMAP_SECURE === 'true',\r\n            tls: {\r\n                rejectUnauthorized: false\r\n            },\r\n            auth: {\r\n                user: email,\r\n                pass: password,\r\n            },\r\n            logger: true\r\n        });\r\n\r\n        console.log('Attempting to connect...');\r\n        await client.connect();\r\n        console.log('Connection successful!');\r\n\r\n        // Test basic mailbox access\r\n        let lock = await client.getMailboxLock('INBOX');\r\n        console.log('Mailbox lock acquired');\r\n\r\n        const status = await client.status('INBOX', { messages: true });\r\n        console.log('Mailbox status:', status);\r\n\r\n        lock.release();\r\n        await client.logout();\r\n        console.log('Connection closed successfully');\r\n\r\n        res.json({\r\n            success: true,\r\n            message: \"IMAP connection successful\",\r\n            mailboxInfo: {\r\n                totalMessages: status.messages,\r\n                mailbox: 'INBOX'\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error('IMAP connection test failed:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            message: \"IMAP connection failed\",\r\n            error: error.message\r\n        });\r\n    }\r\n});\r\n\r\n// Download Attachment\r\nrouter.post('/download-attachment', async (req, res) => {\r\n    const { email, password, uid, folder, index, filename } = req.body;\r\n\r\n    console.log('Download request:', { email: email ? '***@***' : 'missing', password: password ? '***' : 'missing', uid, folder, index, filename });\r\n\r\n    if (!email || !password) {\r\n        console.log('Missing credentials error');\r\n        return res.status(400).json({ success: false, message: \"User credentials required\" });\r\n    }\r\n\r\n    try {\r\n        console.log('Attempting to download attachment...');\r\n        // Ensure folder is properly formatted for IMAP\r\n        const imapFolder = (folder === 'inbox' ? 'INBOX' : folder?.toUpperCase()) || 'INBOX';\r\n        console.log('Using folder:', imapFolder);\r\n\r\n        const attachment = await downloadAttachment(email, password, uid, imapFolder, parseInt(index));\r\n\r\n        console.log('Attachment found:', { filename: attachment.filename, size: attachment.size, contentType: attachment.contentType });\r\n\r\n        // Set appropriate headers\r\n        res.setHeader('Content-Type', attachment.contentType);\r\n        res.setHeader('Content-Disposition', `${attachment.contentDisposition}; filename=\"${attachment.filename}\"`);\r\n        res.setHeader('Content-Length', attachment.size);\r\n\r\n        // Send the attachment content\r\n        res.send(attachment.content);\r\n    } catch (error) {\r\n        console.error('Download attachment error:', error);\r\n        res.status(500).json({ success: false, message: \"Failed to download attachment\", error: error.message });\r\n    }\r\n});\r\n\r\nexport default router;\r\n"
        }
    ]
}